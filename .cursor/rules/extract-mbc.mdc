---
alwaysApply: false
---
# Essential Code Pattern Extraction Rule

When asked to "extract essential code" or "create reference doc" for a module/concept:

## Structure Requirements

Create a reference document with exactly these sections:

### 1. Core Data Structures
- Show essential structs/types only
- Include inline comments for field purposes
- Omit debug/test-only fields

### 2. Essential Pattern Implementation
- Core algorithm or state machine logic
- Initialization sequence
- Main processing loop/callback
- Critical state transitions
- Omit error handling boilerplate unless it's conceptually important

### 3. Helper Functions
- Supporting functions the pattern depends on
- Include actual implementations if < 15 lines
- Show signatures + one-line purpose if longer

### 4. Integration/Usage Example
- How to initialize in main/app
- How client modules use it
- Calling sequence/order matters
- Real example from codebase

### 5. Dependencies
- What external modules/functions it requires
- What it provides to other modules
- Include function signatures and brief implementations

## Formatting Rules

```c
// Use inline comments for field/parameter purposes
struct example {
    uint32_t field;  // What it does
};

// Multi-line comments ONLY for:
// 1. Non-obvious algorithms
// 2. Critical timing/ordering requirements
// 3. Hardware-specific constraints

/* Multi-line: Explain WHY, not WHAT
 * Example: "Must disable interrupts here because..."
 */
```

## What to EXCLUDE

- Console/debug commands (unless core to concept)
- Extensive error handling (show pattern once, assume rest)
- Test infrastructure
- Logging statements
- Statistical counters
- Multiple similar examples (one good example beats three)

## What to INCLUDE

- The "aha!" moment code - what makes this pattern work
- Timing/ordering constraints
- State machine transitions
- Critical relationships between components
- Actual working code, not pseudocode

## Target: One-Page Mental Model

Goal: After reading, engineer can:
1. Explain the concept to someone else
2. Implement it on different hardware
3. Debug issues by understanding the pattern
4. Return months later and quickly recall how it works

## Example Output Format

```markdown
# Most Basic [Concept] Code Reference

## Core Data Structures
[Essential structs with inline comments]

## Essential Pattern Implementation
[The heart of the algorithm - step by step]

### Initialization
[Setup code]

### Main Processing
[Core loop/callback/state machine]

### Cleanup/Shutdown
[If applicable]

## Helper Functions
[Supporting code with implementations]

## Integration Example
[How to use in app_main.c or client module]

## Dependencies
[What it needs from other modules - with code]

## Key Concept Diagram
[ASCII art showing flow/hierarchy if helpful]

**Critical Notes:** [Any gotchas or common mistakes]
```

## Quality Checks

Before finishing, verify:
- [ ] Can fit on 2 pages max when printed
- [ ] No forward references (define before use)
- [ ] Includes actual runnable code, not sketches
- [ ] Shows ONE complete example end-to-end
- [ ] Explains WHY for non-obvious parts
- [ ] Engineer 6 months later can understand it

## Prioritization

If choosing what to include:
1. Core algorithm > error handling
2. State machine > status reporting
3. Critical timing > optimization
4. Working example > multiple variations
5. Essential dependencies > nice-to-have features

This creates **transferable knowledge** - patterns that persist across codebases, hardware, and time.

