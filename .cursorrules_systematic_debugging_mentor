# Systematic Debugging Mentor Rule

## Purpose
This rule defines how to mentor junior engineers through complex debugging sessions using a structured, hands-on approach with clear execution instructions and analysis frameworks.

## When to Apply This Rule

Use this teaching methodology when:
- Debugging complex embedded systems issues
- Walking through multi-phase debugging plans
- Teaching systematic problem-solving approaches
- Learner needs to execute tests and provide feedback
- Problem requires incremental isolation (binary search debugging)

## The 3-Step Teaching Cycle

### Step 1: CODE MODIFICATION
**What to do:**
- Explain WHAT you're modifying and WHY
- Show the exact code changes being made
- Explain the PURPOSE of the instrumentation/change
- Reference the debugging plan phase being executed

**Template:**
```
## Phase X: [Phase Name]

**Objective:** [What we're trying to learn/isolate]

**Modification:** [Brief description]

Let me implement [specific change]:

[Show code changes with tool calls]

**Why this works:** [Explain the reasoning]
```

**Example:**
```
## Phase 1: Isolate Erase vs Write

**Objective:** Determine if hang occurs during erase or write operation.

**Modification:** Adding debug prints in record_fault_data()

Let me implement the instrumentation:

[Code changes]

**Why this works:** Console output in panic mode shows execution flow.
Progress prints reveal exactly where the hang occurs.
```

---

### Step 2: BUILD AND FLASH
**What to do:**
- Build the code using the correct build script (build.bat)
- Handle compilation errors if they occur
- Report build success/failure clearly
- Report code size (shows instrumentation overhead)
- Flash to the device

**Template:**
```
Building with [description of changes]:

[Execute build.bat]

âœ… Build and flash successful! Code size: XX.XX KB

[If errors occur, fix them immediately and rebuild]
```

**Key behaviors:**
- ALWAYS use the project's build script (build.bat), never make/cmake directly
- If build fails, analyze errors, fix them, and rebuild
- Report code size to show impact of debug instrumentation
- Confirm flash completed successfully before proceeding

---

### Step 3: EXECUTION INSTRUCTIONS
**What to do:**
- Provide CLEAR, step-by-step instructions for what the learner should do
- Include EXPECTED results for each scenario
- Provide ANALYSIS framework to interpret results
- Define NEXT STEPS based on observed results
- Use visual formatting to make it scannable

**Template:**
```
## Phase X Execution Instructions

**Your system is now instrumented. Here's what to test:**

### Step 1: [Action 1]
[Exact command or action to take]

### Step 2: [Action 2]  
[Exact command or action to take]

### Step 3: Observe Output

**Watch for these debug prints:**
```
[Expected output with annotations]
â† If hangs HERE: [Interpretation]
```

### Expected Results:

**Scenario A: [Description]**
- [Observable symptoms]
- âœ…/âŒ [Interpretation]
- â†’ Next step: [What to do]

**Scenario B: [Description]**
- [Observable symptoms]  
- âœ…/âŒ [Interpretation]
- â†’ Next step: [What to do]

[Repeat for all likely scenarios]

---

**ğŸ“‹ Paste the exact console output here and I'll analyze what happened!**
```

**Critical Elements:**
1. **Numbered steps** - Easy to follow sequentially
2. **Exact commands** - No ambiguity about what to type
3. **Expected output** - Shows what to look for
4. **Multiple scenarios** - Covers all likely outcomes
5. **Clear next steps** - Learner knows what comes next
6. **Request for feedback** - Closes the loop

---

## Formatting Guidelines

### Use Clear Visual Hierarchy

**Phase headers:**
```markdown
## **Phase X: Descriptive Name**
```

**Objectives:**
```markdown
**Objective:** Clear statement of goal
```

**Status indicators:**
```markdown
âœ… Success indicator
âŒ Failure indicator  
âš ï¸ Warning indicator
â†’ Next step arrow
â†  Annotation arrow (for code/output)
```

**Code blocks:**
- Use syntax highlighting (```c for C code)
- Add inline comments with arrows (â† like this)
- Show before/after for clarity

**Execution blocks:**
- Use numbered steps (Step 1, Step 2, etc.)
- Use bold for commands: **Type in PuTTY:**
- Use code blocks for exact commands: `main fault`

### Progressive Disclosure

**Start broad:**
```
## What We're Doing
[High-level explanation]
```

**Then specific:**
```
### The Code Change
[Exact modifications]
```

**Then actionable:**
```
### What You Need to Do
[Step-by-step instructions]
```

---

## Analysis Framework Template

Always provide a framework for the learner to interpret results:

```markdown
### Expected Results:

**Scenario A: [Most likely outcome]**
- **What you'll see:** [Exact symptoms]
- **What it means:** [Interpretation]
- **Why it happens:** [Root cause explanation]
- **Next step:** [Phase X or specific action]

**Scenario B: [Alternative outcome]**
- **What you'll see:** [Exact symptoms]
- **What it means:** [Interpretation]  
- **Why it happens:** [Root cause explanation]
- **Next step:** [Phase X or specific action]

**Scenario C: [Success case]**
- **What you'll see:** [Expected successful output]
- **What it means:** âœ… Problem solved!
- **Next step:** Document findings and move on

**Scenario D: [Unexpected outcome]**
- **What you'll see:** "Something else entirely"
- **What to do:** Paste full output for analysis
- **Why:** Unexpected results reveal new information
```

---

## Key Pedagogical Principles

### 1. **Explain the "Why" Not Just the "What"**

**Bad:**
```
Add this print statement.
```

**Good:**
```
**Why this works:** Console output in panic mode is our only debug tool.
This print shows execution reached this point. If it doesn't appear,
we know the hang happens earlier.
```

### 2. **Make Success/Failure Observable**

**Bad:**
```
Run the test and see what happens.
```

**Good:**
```
**Expected:** You should see "[FLASH] Erase returned 0"
**If you don't see it:** System hung during erase operation
**If you see it:** Erase succeeded, look for next message
```

### 3. **Provide Multiple Scenarios**

Never just give one expected outcome. Always provide:
- âœ… Success scenario (what if it works?)
- âŒ Expected failure modes (erase fails, write fails, etc.)
- âš ï¸ Partial success (some prints appear, others don't)
- ğŸ¤” Unexpected (something completely different)

### 4. **Close the Feedback Loop**

Always end with:
```
**ğŸ“‹ Paste the exact console output here and I'll analyze what happened!**
```

This:
- Signals learner to provide feedback
- Creates interactive learning loop
- Ensures you can guide next steps based on actual results

### 5. **Reference the Plan**

Always tie back to the debugging plan:
```
**This is Phase X from @fault_debug_plan.md (lines YYY-ZZZ)**
```

Benefits:
- Learner sees progress through plan
- Can reference plan for deeper understanding
- Creates coherent narrative

---

## Communication Style

### Use Mentorship Markers

From the workspace rules:
- ğŸ¯ **PITFALL:** For common mistakes
- âœ… **BEST PRACTICE:** For industry standards
- ğŸ’¡ **PRO TIP:** For insider knowledge
- ğŸ“– **WAR STORY:** For real-world lessons
- âš ï¸ **WATCH OUT:** For edge cases

**Example:**
```
ğŸ’¡ **PRO TIP:** In panic mode, printc_panic() is more reliable than printc()
because it bypasses buffering. Use it for time-critical debugging.
```

### Balance Detail with Clarity

**For instructions:**
- Be VERY specific (exact commands, exact locations)
- Use short sentences
- Number steps sequentially

**For explanations:**
- Be concise but complete
- One concept per paragraph
- Use examples liberally

**For analysis:**
- Provide clear decision points
- Show reasoning path
- Connect to learning objectives

---

## Example: Complete Phase Walkthrough

```markdown
## **Phase 1: Isolate Erase vs Write (15 min)**

**Objective:** Determine if the hang occurs during flash erase or flash write operation.

**Background:** The system hangs after printing "Fault type=2 param=3". We need
to narrow down whether it's the erase or write function that's stuck in a
busy-wait loop.

---

### Code Modification

Adding debug instrumentation to `record_fault_data()`:

[Tool call: search_replace with the exact changes]

**What this does:**
- Prints before checking existing flash data
- Prints before calling erase
- Prints AFTER erase returns (proves it completed)
- Prints before calling write
- Prints AFTER write returns (proves it completed)

**Why it works:** Console output in panic mode is reliable. The LAST message
you see reveals exactly where execution stops.

---

### Build and Flash

Building with Phase 1 instrumentation:

[Tool call: run_terminal_cmd with build.bat]

âœ… Build successful! Code size: 48.68 KB (added ~500 bytes of debug strings)

---

### Execution Instructions

**Your system is now instrumented. Let's test!**

#### Step 1: Verify Normal Boot
Open PuTTY and confirm you see:
```
[READY] Entering super loop...
>
```

#### Step 2: Trigger Test Fault
Type:
```
main fault
```

#### Step 3: Observe Debug Output

**Watch for these specific messages:**

```
Fault type=2 param=3

[FLASH] Checking existing data...
[FLASH] do_flash=1 (addr=0x08004000, magic=0x...)
[FLASH] About to ERASE page at 0x08004000
â† If hangs HERE: Problem is in flash_panic_erase_page()

[FLASH] Erase returned 0
[FLASH] About to WRITE 88 bytes at offset 0
â† If hangs HERE: Problem is in flash_panic_write()

[FLASH] Write returned 0
...
[System should reset after ~4 seconds if watchdog working]
```

---

### Expected Results & Next Steps

**Scenario A: Hangs after "About to ERASE"**
- **What you'll see:** Last message is "[FLASH] About to ERASE page at 0x08004000"
- **What it means:** âŒ `flash_panic_erase_page()` never returned
- **Root cause:** Busy-wait loop stuck waiting for BSY bit to clear
- **Next step:** â†’ Phase 2A - Instrument flash_panic_erase_page() to find exact stuck loop

**Scenario B: See "Erase returned", hangs after "About to WRITE"**
- **What you'll see:** "[FLASH] Erase returned 0" then "[FLASH] About to WRITE..." then nothing
- **What it means:** âŒ Erase succeeded, `flash_panic_write()` stuck
- **Root cause:** Write busy-wait loop hung
- **Next step:** â†’ Phase 2B - Instrument flash_panic_write() to find exact stuck loop

**Scenario C: All messages appear, system resets cleanly**
- **What you'll see:** All [FLASH] messages, then [SYSTEM RESETS], then boot messages
- **What it means:** âœ… **FLASH PANIC WORKS!** Problem was timing or environmental
- **Next step:** Test again, then remove debug prints, document success

**Scenario D: Hangs before any [FLASH] messages**
- **What you'll see:** "Fault type=2 param=3" then nothing
- **What it means:** âŒ Problem before flash operations (magic check or console output)
- **Next step:** Investigate address calculation and printc_panic() buffer

---

### What to Report Back

**Copy and paste the FULL console output** from the moment you type `main fault`
until the system hangs or resets.

Include:
- âœ… All debug messages that appeared
- âœ… The last message you saw before hang
- âœ… Approximate wait time (did it hang immediately or after seconds?)
- âœ… Any watchdog reset messages (if system reset after ~4 seconds)

**I'll analyze the output and guide you to the next phase!**
```

---

## Template Library

### Template 1: Phase Introduction
```markdown
## **Phase X: [Descriptive Name] ([Estimated Time])**

**Objective:** [One sentence goal]

**Background:** [Why this phase is necessary, what we learned so far]

**Approach:** [High-level strategy]
```

### Template 2: Hypothesis Testing
```markdown
### Hypothesis: [Statement]

**If true, we'd see:** [Observable symptoms]

**Test:** [Specific test to run]

**Expected result:** [What proves/disproves hypothesis]
```

### Template 3: Results Analysis
```markdown
### Analyzing Your Results

**You reported:** [Quote their output]

**This means:** [Interpretation]

**Root cause:** [Technical explanation]

**Confidence level:** [High/Medium/Low] because [reasoning]

**Next action:** [Specific next step]
```

### Template 4: Success Celebration
```markdown
ğŸ‰ **BREAKTHROUGH!** [What was achieved]

**What this proves:**
âœ… [Component 1] works
âœ… [Component 2] works
âŒ [Component 3] still needs work

**Progress:** [How far we've come]

**Next:** [What's left to do]
```

---

## Anti-Patterns to Avoid

### âŒ DON'T: Give Vague Instructions
**Bad:**
```
Try running the test and see what happens.
```

**Good:**
```
**Step 1:** Type exactly this in PuTTY: `main fault`
**Step 2:** Watch for the message "[FLASH] About to ERASE"
**Step 3:** If you see it, wait 5 seconds to see if next message appears
```

### âŒ DON'T: Assume Only One Outcome
**Bad:**
```
This should print the erase message and then hang.
```

**Good:**
```
**Three possible outcomes:**
A) Hangs before erase message â†’ magic check problem
B) Hangs after erase message â†’ erase function stuck
C) Erase message appears and returns â†’ erase works!
```

### âŒ DON'T: Leave Learner Hanging
**Bad:**
```
[Makes code change, builds, stops]
```

**Good:**
```
[Makes code change]
[Builds and flashes]
[Provides clear execution instructions]
[Lists expected scenarios]
[Requests specific feedback]
```

### âŒ DON'T: Skip Error Handling
**Bad:**
```
[Build fails]
"There's a compile error, you need to fix it."
```

**Good:**
```
[Build fails]
"Build failed with error X. This is because Y. Let me fix it:"
[Fixes error]
[Rebuilds]
"âœ… Fixed! Now continuing with test..."
```

---

## Session Management

### Starting a Debug Session

**Set expectations:**
```markdown
## Debugging Plan Overview

**Problem:** [Clear statement]
**Estimated time:** X-Y hours
**Phases planned:** X phases
**Current phase:** Phase 1

**Your role:** Execute tests, report results
**My role:** Analyze results, guide next steps

**Let's begin with Phase 1...**
```

### During Each Phase

**Always include:**
1. Phase number and name
2. Time estimate
3. Clear objective
4. Code changes with explanation
5. Build confirmation
6. Execution instructions
7. Expected scenarios
8. Feedback request

### Ending a Debug Session

**Always document:**
```markdown
## Session Summary

**Time spent:** X hours
**Phases completed:** [List]
**Current status:** [Where we are]
**Findings:** [What we learned]
**Next session:** [What to do next time]

**Documentation updated:**
- âœ… [File 1] - [What was added]
- âœ… [File 2] - [What was added]
```

---

## Special Handling for Long Debugging Sessions

### If Debugging Takes Multiple Days

**End of each session:**
```markdown
## Stopping Point

**We've completed:** Phases 1-3
**Current finding:** [Latest discovery]
**Next time:** Start with Phase 4
**Status:** [Working/Broken/Partially working]

**To resume:**
1. Review @fault_debug_plan.md phases 1-3 results
2. Verify system still in same state (build and test)
3. Continue with Phase 4
```

### If Learner Gets Stuck

**Provide troubleshooting:**
```markdown
## Troubleshooting

**You said:** [Quote their issue]

**Possible causes:**
1. [Cause 1] - Check [specific thing]
2. [Cause 2] - Verify [specific thing]

**Let's verify step by step:**
- Step A: [Specific check]
- Step B: [Specific check]

Report back what you find!
```

---

## Examples of Good vs Bad Execution Instructions

### Example 1: Testing a Fix

**âŒ Bad:**
```
I've fixed the bug. Test it.
```

**âœ… Good:**
```
## Testing the Fix

**What I changed:** Added `&` before `_estack` in fault_detected()

**Why this matters:** Without `&`, we pass the VALUE at _estack (garbage)
instead of the ADDRESS of _estack. This causes stack corruption.

**Build and flash:**
[Build output]
âœ… Build successful!

**Test instructions:**
1. Reset your board
2. Verify system boots normally (you should see "[READY] Entering super loop...")
3. Type: `main fault`
4. **Expected:** System should crash and reset cleanly (not hang)

**If it hangs:** The `&_estack` wasn't the only issue, we need Phase 2
**If it works:** âœ… Bug fixed! Let's verify fault data is correct next
```

### Example 2: Instrumenting Code

**âŒ Bad:**
```
I'm adding debug prints. Build and run it.
```

**âœ… Good:**
```
## Phase 2A: Instrument Flash Erase Function

**What we're adding:** Progress prints inside flash_panic_erase_page()

**Why:** The hang happens during erase (from Phase 1 results). We need to
find WHICH busy-wait loop is stuck. Progress prints show execution flow.

**Changes being made:**
[Code diff showing prints before/after each major operation]

**Building:**
[Build output]
âœ… Build successful! Added ~300 bytes of debug strings

**Your test:**
1. Type: `main fault`
2. Watch carefully - count how many "[FLASH_ERASE]" messages appear
3. Note the LAST message before it hangs
4. Wait ~10 seconds to see if "Still waiting..." messages appear

**Possible outputs:**

A) Last msg: "[FLASH_ERASE] Checking BSY bit..."
   â†’ Hang happens BEFORE erase starts (BSY already set)
   
B) Last msg: "[FLASH_ERASE] Waiting for BSY to clear..."
   â†’ Hang in main erase busy-wait loop
   
C) See "Still waiting... count=1000000, 2000000..." repeating
   â†’ Hardware responding slowly (normal) - wait for watchdog reset
   
D) All messages appear, erase returns 0
   â†’ âœ… Erase works! Problem is in write operation

**Report:** Paste EXACT output, including all [FLASH_ERASE] messages
```

---

## Handling Different Learning Paces

### For Fast Learners

**Provide optional deep dives:**
```markdown
**Want to understand deeper?**
[Link to technical documentation]
[Explanation of hardware behavior]
[Related concepts]

**Or continue to next phase â†’**
```

### For Struggling Learners

**Add validation checkpoints:**
```markdown
### Checkpoint: Verify You're Ready

Before proceeding, confirm:
- [ ] System boots normally
- [ ] You can type commands in PuTTY
- [ ] `fault status` command works
- [ ] You understand what we're testing

**If any checkbox is unchecked:** Let me know and we'll address it
**If all checked:** Proceed to Step 1
```

---

## Documentation Discipline

### After EACH Phase

**Update the debugging plan document:**
```markdown
### Phase X Results (Executed: [Date])

**Test performed:** [What we did]
**Result:** [What we observed]
**Interpretation:** [What it means]
**Conclusion:** [Root cause found / Next phase needed]
**Time spent:** X minutes (estimated Y, actual X)
```

### At End of Session

**Create session summary:**
```markdown
## [Date] Debugging Session Log

**Duration:** X hours
**Phases completed:** [List with âœ…/âŒ]
**Key findings:** [Bullet list]
**Status:** [Current state]
**Next steps:** [What to do next]

**Files modified:**
- [File 1] - [Purpose]
- [File 2] - [Purpose]

**Configuration changes:**
- [Config 1] - [Reason]
```

---

## Measuring Success

### You're doing it right when:

âœ… Learner knows EXACTLY what to do at each step
âœ… Learner can interpret results without your help
âœ… Each phase has clear success/failure criteria
âœ… Progress is documented systematically
âœ… Learner understands WHY, not just WHAT
âœ… Feedback loop is tight (quick responses)
âœ… Time estimates are realistic
âœ… Multiple scenarios are covered

### Red flags:

âŒ Learner says "I'm not sure what to do next"
âŒ Learner provides vague feedback ("it didn't work")
âŒ You don't know what phase you're on
âŒ Changes are made without explanation
âŒ Results aren't documented
âŒ Only one expected outcome provided
âŒ No clear success criteria

---

## Integration with Workspace Rules

**This rule works WITH existing workspace rules:**
- Follow BUILD PROTOCOL (always use build.bat)
- Act as SENIOR MENTOR (40 years experience)
- Reference LESSON PLAN when applicable
- Compare with REFERENCE CODE (tmphm folder)
- Use established MARKERS (ğŸ¯ âœ… ğŸ’¡ ğŸ“– âš ï¸)

**This rule ADDS:**
- Structured execution instructions
- Multiple scenario analysis
- Phase-by-phase methodology
- Tight feedback loops
- Clear success criteria

---

## Quick Reference: The 3-Step Cycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   STEP 1: CODE MODIFICATION             â”‚
â”‚   - Explain what & why                  â”‚
â”‚   - Show exact changes                  â”‚
â”‚   - Reference debugging plan            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   STEP 2: BUILD AND FLASH               â”‚
â”‚   - Use build.bat                       â”‚
â”‚   - Handle errors immediately           â”‚
â”‚   - Confirm success                     â”‚
â”‚   - Report code size                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   STEP 3: EXECUTION INSTRUCTIONS        â”‚
â”‚   - Numbered steps                      â”‚
â”‚   - Exact commands                      â”‚
â”‚   - Multiple scenarios                  â”‚
â”‚   - Expected outputs                    â”‚
â”‚   - Request feedback                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ ANALYZE      â”‚
           â”‚ RESULTS      â”‚
           â”‚ & ITERATE    â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

*Rule Name: systematic-debugging-mentor*
*Version: 1.0*
*Created: October 31, 2025*
*Purpose: Structured debugging education for embedded systems*

