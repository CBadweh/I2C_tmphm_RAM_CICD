00:00 this is part two of the lesson on the design and implementation of the i2c driver module in this part we focus on
00:08 the implementation and a demo so here are the topics
00:13 we start by going through the ide configuration for i2c and generating the startup code
00:20 then we look at the overall software structure to see how the i2c
00:25 module fits in next we look at a few highlights of the module code
00:31 and then the initialization code that was generated by the ide
00:37 and finally i'll show how this module is integrated into the module startup and
00:42 super loop following that we'll go through a demo where we'll look at a few use cases
00:48 we'll make use of the logic analyzer to see the bus activity on the wire finally after a short summary i'll
00:55 provide some prompts or questions for you to try to answer for each prompt i'll give you a second to pause the
01:02 video and then give you my take on the prompt here we are in the ide and i want to
01:09 very briefly show you how i have i2c configured now this configuration is mainly the default for
01:16 the nucleo board except i have uart 6 enabled here for reasons unrelated to
01:22 this course so regarding i2c i chose to use i2c
01:27 number three because i originally wanted you to use some specific pins in the end
01:33 it didn't matter but i just stuck with those pins so i'll enable that i2c here
01:40 it's i2c3 let's open it up enable it
01:47 regarding the parameters i just used the defaults including the bitrate which is 100 kilobits per second
01:56 now it chose these pins but i wanted sda to be on pb4
02:03 so i just do this id i2c3sda
02:09 and it's it moved it to pin 4. notice it took it away from here it also pinned it
02:14 which means if i were doing more work on this mcu assigning other peripherals it would
02:20 not be it would not move that pin to something else or that that function so then i want to make sure we're using
02:28 the low level library and so i go to the project manager advanced settings
02:34 and here is i2c i2c3 and it's not using low level so we will
02:40 change that so i think we're good on the configuration the last thing i want to
02:46 do is generate the code and there we go
02:52 and that has started i'm gonna pause here the video
02:57 because this might take a little bit okay so the code generation was
03:02 successful and so we're good to go with that code
03:08 this slide gives a complete overview of the structure of the software for the course project this is to help you see
03:14 how the i2c module fits in by the way this software structure was covered in
03:20 detail in my previous base mcu course so it's roughly in layers and we'll start at the bottom with the system code
03:27 and libraries which are the gray boxes first we have the power-up code which is
03:32 the first instructions executed when power is applied and the interrupt vector table which controls which code
03:38 is executed for the various interrupts the power-up code does the bare minimum
03:44 to provide an environment for normal c code to run next we have the standard c libraries of
03:51 libsy and libm as you may know there are lightweight implementations of these libraries
03:58 called new live and an even lighter weight version called new live dash nano
04:04 finally we have the c language runtime code which is also very low
04:09 level stuff it is closely tied to the compiler normally you never think about this code but i just included it for
04:16 completeness so now let's move up a level to the hardware access libraries which
04:22 are in these light brown boxes these are mainly register level access
04:28 used by higher layers there is the census library which is for
04:34 the cpu and core peripherals like the interrupt controller floating point unit and so forth
04:40 and then there is the low-level library or ll which is for non-core peripherals
04:46 like uarts and the i2c interfaces now the next level up
04:52 is ide provided startup code which is in this light green box
04:58 some of this code is generated by the id e and depends on which peripherals you have configured obviously for our
05:06 project we have configured an i2c interface among other stuff
05:11 so this code will initialize most of the hardware peripherals except maybe for
05:18 stuff that is done up in the modules now all the software we've discussed so
05:24 far has been provided by the ide including the tool chain now we move into code
05:30 that i have written for this course in the base course and this is the co the code that is in the github repo
05:37 so first we have the module startup and super loop in this bright blue box
05:42 this code first just brings all these modules through two stages of initialization using standard apis then
05:50 it runs the super loop which also invokes these modules or a subset of them through a standard api
05:58 above that we have a set of modules in bluish gray
06:04 these are the modules that use the census or ll apis and thus are hardware
06:09 dependent so if we were to move this software to another mcu with different hardware these modules would have to be
06:15 modified but their value is they provide a hardware independent interface to their
06:21 users and thus they provide hardware abstraction we'll see how this works shortly
06:26 the i2c module is the one we'll be discussing in this lesson so it has a red border to highlight it
06:33 at the top level are modules that are hardware independent one way one way they achieve this is by making use of
06:40 these lower modules that provide a hardware abstraction
06:46 an example is this temp hum module which stands for temperature humidity it is
06:52 highlighted with a red border since we'll be looking at it later in this course it accesses a sensor that has an i2c
06:59 interface but it achieves mcu hardware independence by using the i2c module
07:07 if we were to move this module to another platform another mcu it should not have
07:13 to be changed so here's the code for the i2c module there's a fair amount of code in
07:20 here although a lot of it is infrastructure stuff like console commands i don't want to spend a lot of
07:25 time looking at this code i'm just going to give you a few highlights and so the first thing
07:33 is this enumeration for states these are the states we actually looked at in that
07:39 state diagram just a little bit ago in that state diagram i i abbreviated them but there they are
07:46 and then here is a key data structure in almost all drivers you'll see
07:51 is i call state which is a little bit confusing but this is all of the data
07:56 associated with a particular i2c instance and so if we have multiple instances there'll be multiple instances
08:03 of this data structure and it contains information like the configuration a pointer to the
08:11 peripheral registers the i2c device some information about the message
08:16 buffer this boolean here indicates whether or not this instance has been reserved
08:23 here's the actual state and then we store some error information
08:29 so the next thing i want to show is just one of the apis this is a simple one
08:34 called reserve so here it is i2c reserve it takes an
08:42 instance it does some error checking but if all goes well
08:47 uh it sets the reserved flag in that data structure to to true and
08:53 now the instance is reserved this reservation system is is quite simple and we'll talk
08:59 about that in one of the prompts so next i want to look at some
09:06 uh um interrupts and let's go to
09:11 522. so this function here this this symbol is in the interrupt vector table
09:19 and there is a default implementation for this that is just a tight loop
09:24 that default implementation the symbol for it is weak which means we can override it which is what we're doing
09:30 here and there's quite a few of these for the different instances and they all call a single interrupt
09:37 handler here called i2c interrupt so we can go to that
09:42 and you'll see we pass in the instance id and the type of interrupt so the purpose of the interrupt handler
09:49 is to react to the event that just occurred and that which is essentially what a
09:55 state machine does and so a good portion of the state machine is in this
10:01 interrupt handler and this state machine implementation is
10:06 what i would call informal very informal the way you can
10:11 spot informal implementations is they often have a number of switch statements in them in this case we're switching on
10:18 the state more formal state machines will sometimes have
10:23 tables of functions and the nice thing about formal implementations is they're often better
10:30 they force you to consider every state every event and every state
10:35 in to make sure you haven't missed something and in these informal implementations
10:41 sometimes you sort of have to do that yourself and make sure you didn't miss anything so and because that can lead to state
10:48 machines getting stuck and all sorts of things so let's just look at this
10:53 we do a switch on the state if we're in the right generating start condition what we normally expect is the sb bit to
11:03 be set in status register one and if that is true it means the start
11:08 condition was generated and we now write the address and the
11:13 read write bit to the data register and the state advances to
11:19 write sending address i'll mention here what's going on here this is just my
11:27 idea i keep track in this variable which bits we have looked at or considered and
11:34 in this case this says we have handled the sb bit what that's used for is later
11:40 in this interrupt handler we check to make sure there aren't any other bits set that would be unexpected
11:48 in this in this case based on this state and if any of those other bits are set that
11:55 means something unusual is happening and we have a very simple
12:00 response to that we end the transaction and we say it failed
12:05 now maybe in other drivers you'd have to be a little bit more sophisticated than that
12:11 so this is i hope gives you a little flavor of what the code looks like how the state machine is
12:17 implemented and if you are interested you certainly could look at this in greater detail you
12:24 will see that there is a lot more complexity a fair more complexity than that state machine
12:31 diagram the state machine diagram is accurate in the sense of it shows the transitions reasonably well but there
12:38 are a lot more things checked and as i mentioned there those so-called special instructions add some complexity
12:46 in some of these states so here we are
12:51 in the main.c file for our ide project and this is generated code i want to
12:58 show you the startup code for the i2c instance we are using now in order for this code to be
13:04 generated we enabled the i2c device in the ide and we also specified that it should use
13:11 the library in any generated code so if we scroll down a little bit we
13:18 will find the main function right here and scrolling down within that function
13:25 we see the initialization of the peripherals and here is the
13:30 function call for the i2c device i2c number three
13:36 and if i go to that function we can look to see what it does
13:41 there's two main things it has to do it has to set up the gpio pins for
13:46 the i2c interface and then it has to set up the i2c peripheral itself
13:53 so regarding the gpio pins it enables the
13:58 clock for the gpio ports and then it fills out these data structures one for the sda signal one
14:06 for the scl signal this is information about the gpio pin
14:12 and then it calls this l function which takes this information and
14:18 writes it into registers very straightforward function so once the gpio pins are set up it
14:26 works on the actual peripheral it enables the clock for that peripheral
14:32 and then it does something it sets a few things up uh for instance enabling clock
14:38 stretching as a is one example and then it does something similar as
14:43 for gpio it fills out a data structure with all the information about the
14:51 i2c device here happens to be the bit rate and
14:56 then it calls this ll function and again this ll function takes this information
15:02 out of the structure and writes it into registers and that's it
15:08 so it's not a lot of code so this is the last code file we'll look
15:14 at it's called app main and it contains the module startup and the super loop i just
15:20 want to show you how the i2c module is integrated
15:26 so i'm going to jump directly to some lines
15:34 here is the structure for the the configuration structure for the
15:40 i2c module and then i am going to scroll down a little bit
15:47 and right here is where we get the default parameters
15:54 for this i2c instance and we store them in that structure and then as soon as that happens we call
16:00 i2c init which is the first phase of initialization
16:06 so i will scroll a little bit more and of course this is being done for lots of different modules
16:12 here is the second stage of initialization called
16:18 i2c start and that's really it now here is the super loop
16:25 and if this module had a run function we would be calling it in the super loop
16:31 but it doesn't the i2c module works entirely based on interrupts
16:38 now i want to do a few demos of this module what i have here on the top of the screen is the logic analyzer program
16:44 from celia it's called logic and i have a logic probe connected to this as i
16:50 showed in the first lesson on the bottom of the screen i have the mcu console so i can enter commands
16:58 so i won't go through the setup of this logic analyzer in detail i'll just show you what i
17:04 have or how i have configured it so this shows the configuration of the all
17:12 the channels or the probes and i have one channel
17:17 i named sda another one i named scl and the remaining six channels are all
17:23 hidden i'm sampling at two mega samples per second there are faster
17:30 sample rates but i was having some problems i'm not sure if it's problems with my
17:36 laptop because i'm running a lot of software when i make these videos or maybe it's a problem because i have a
17:42 really cheap logic probe compared to the really nice ones from
17:47 saylia the other thing i would like to show you is i have a trigger setup a trigger is
17:52 something that will start recording data and i have the trigger defined this means a falling edge on sda
18:01 and if i can open this a high condition on scl and that is the
18:07 definition of a start condition so that is a natural trigger
18:12 the other thing i want to show you is the an analyzer i have configured this
18:18 to uh for i2c analysis and when you set it to ie2c it'll ask you which channel is
18:24 sda which channel is scl and um this is some previous tests so you don't
18:30 have to look at that we'll be looking at more of that in just a second
18:36 so first i would like to try um a basic right and a read
18:43 i have a temperature sensor device connected to this and it's at address
18:49 44. so the first thing we can do well let me show you first there is an i2c test
18:56 command and if i enter it with no other parameters it just gives me a list of all the different options and you can
19:03 thing see things like reserve release start a write start a read and so forth
19:09 so i happen to know what the command is uh to tell that device to
19:17 us start a measurement and this is it so we're going to do a write
19:23 instance 0 i2c instant 0. there is only one instance in this
19:28 software load here's the address of the device and these are the two data
19:33 bytes and if i hit that uh i got an error um i forgot to reserve
19:40 the device so let me do that
19:48 reserve instance zero and that succeeded so now oh before i do the right i i
19:55 forgot i want to start the analyzer so it will start looking for the um
20:00 the start condition and there it goes it's uh looking
20:07 so now let's reissue the right and
20:12 we got a uh trigger and you can't see it it's it's it would
20:18 be on here but it's off the screen right now but we can look at the data and we can see it's uh you know there's
20:25 a start there's an address two data bytes and a stop and here's what's really nice if i click
20:31 on this it'll bring that to the center of the display so here let me just move this over a little
20:37 so here's the entire transaction this this t means this was the trigger
20:42 point and that also happens that green dot is saying this is a start condition here
20:48 is the address by plus the read write byte being
20:54 written and it's act and then here are the two data two data bytes and they are act
21:01 and then this orange dot means that that means it's a stop
21:07 condition so we have given it the command now the next thing we want to do is read
21:14 the result and i'm just going to cut and paste that
21:22 i happen to know that this device the result is
21:28 contained in six bytes so here this command is going to do a read
21:33 again instant 0 address 44 and it wants to read 6 bytes let me start the analyzer
21:41 make sure it's running and i'll hit this and we have that and here are the
21:48 uh the the data being read again i will click on this to get to the beginning of the
21:54 transaction and this looks a lot like that right except now it's a read instead of a
21:60 right and if i go over a little bit more
22:05 one thing i'll point out while i'm here is that it very conveniently labels the rising edge of the clock
22:14 signal and if you remember from the course on the theory of operation
22:20 that is when the sda signal is sampled and for whatever
22:25 reason um for the acknack bit it doesn't show that arrow and i i mean
22:32 that's that's fine i think it sort of helps you find out which rising um clock signal is for the acknack bit
22:40 but the main thing i want to show you here back to the read is that the last byte was knacked and that's if you
22:47 remember that's how reads work in i2c so now i would like to show you and let me just
22:54 restart the analyzer i would like to show you a an error case
23:00 and so what we're going to do is try to read a non-existent address so i'm going
23:06 to do a test read instant 0 address let's just say 11. i just some random
23:13 value and how many bytes it doesn't really matter i'll just say 2 bytes
23:18 and we got something so let's look at that and so here same thing we here's the
23:25 start condition we're starting or trying to do a read but in this case it tells us the
23:31 analyzer figured out it was knacked and we can look at that and convince
23:37 ourselves it was an act this rising edge of the clock is where the acmac
23:42 um is sampled and you can see the signal is high if you remember an ack is low
23:49 so that address was knacked what happened in the driver is we got it would have
23:54 gotten an interrupt with an error bit set i believe the error is called af for address failure and the driver would
24:01 then us generate a stop condition and the transaction failed and here of course is
24:07 the stop transition and i can actually do use another one of the apis called
24:15 the get operation status so we want to get the operation status for instance zero
24:21 and this first thing is a module error code and -7
24:28 is defined as peripheral error and that is sort of a generic um status
24:34 and then you can then go to the module and say give me the the detailed error and error number six me would mean uh
24:41 address failure again if you looked at the header file for um the i2c module
24:47 and the other thing i'd like to show is the general status command
24:54 and what it does is for every instance uh it gives you just so some of
24:60 the information out of that state structure this one here is saying that this module is reserved um
25:07 this is telling you some information about the last operation that was attempted
25:13 including errors and so forth and also shows you what the base address is of that module
25:19 and then the other thing i'd like to show is the performance measurements
25:25 and [Music] these are generally error cases now this reserve fail i'll tell you about that in
25:32 just a second the one i wanted to point out is it does show that there was one acknowledgement failure
25:38 this reservation failure is because there is another module running in this
25:44 system we're going to talk about it in the next lesson and it's trying to also access this
25:50 device but since i reserved it it is unable to reserve it so it's constantly trying to
25:56 reserve it and it's failing each time these pm counters are limited to
26:02 they're 16 bits so this is the maximum value so it's just sitting at that value
26:08 so that is a little demo of the module and the showing some of the console commands and
26:14 showing the logic analyzer which i hope you can see is very useful when you're trying to debug a problem
26:21 so here's a summary of this lesson a minimal viable product for an i2c driver would support single master
26:27 operation 7-bit addressing and simple reads and writes the design of a module like i2c tends to
26:35 be iterative and includes close reading of the data sheet or reference manual making high-level design decisions
26:43 developing a state machine in many cases coding and testing
26:48 a state machine can be used as the model for an i2c driver where the states are typically the waiting points in an i2c
26:56 bus transaction console test commands are handy for manual testing of i2c devices and
27:03 inherently the driver itself and a logic analyzer is very beneficial
27:08 to see what is happening on the bus for debugging
27:13 here are the prompts for this video lesson i should mention that some of these prompts especially the first one
27:19 requires some analysis of the code so i'll pause here for a few seconds in
27:25 case you want to pause the video and look at these as a group on the next set of slides i'll go
27:30 through the prompts one by one and reveal my take
27:36 what global or static variables or i2c peripheral registers if any are modified
27:43 both at the software base level and at the interrupt level if there are any
27:49 what prevents simultaneous modifies and thus possible data corruption
27:58 well the i2c write and i2c read functions with which execute at the base level
28:04 call startup and it modifies some fields in the i2c state structure
28:11 and the i2c hardware registers and these same fields and registers are
28:16 modified in i2c interrupt or functions called by this interrupt handler
28:22 and some examples of the fields are in i2c state are message bytes
28:27 transferred last stop error and last stop state and examples of registers are
28:34 control register 1 and control register 2. this isn't a problem
28:40 because startup immediately returns if the module is not in the idle state
28:46 but when the module is in the idle state i2c interrupts are disabled so
28:52 simultaneous modifiers are not possible
28:58 describe weaknesses of the guard timer implementation in this module and suggest possible improvements
29:08 well it's not too bad but for the guard timer we have just a single timer with a single timeout value
29:16 and it's used to cover the entire i2c pr procedure
29:21 and this is an optimal for example if there is a problem generating the start condition
29:28 we have to wait a much longer time before we report that error than we would have to and that's because the
29:35 timeout value has to be made to accommodate the longest possible i2c transaction
29:43 so the improvement would be that you could update the guard timer
29:49 timeout period in each state to a value that is appropriate for that
29:55 state and this isn't uh uncommon in state machines often each state will have its own guard timer and
30:02 in some cases that guard timer might be quite small other cases it would be longer
30:09 describe weaknesses of the reservation scheme and suggest possible improvements and by reservation scheme i mean where
30:16 you have to call i2c reserve before you can do an i2c read or write
30:24 so some weaknesses include it's based on the honor system it depends on all users to play by the
30:31 rules and properly reserving and releasing the i2c bus as it works now if
30:36 user a has reserved the bus then user b could skip the reservation and try to
30:41 use the bus directly the module only checks that someone has reserved it
30:48 another issue is that if a user forgets to release the reservation the i2c is
30:55 locked out for all users perhaps forever and when i say forgets what i really mean is that there's some bug in the
31:01 user code maybe some unusual scenario occurs and the code does not release the
31:07 bus finally there is no method to ensure fairness in other words grant
31:13 reservations in the order of the request basically when the bus is freed the first user to call i2c reserve gets it
31:21 so some possible improvements one is when a reservation is granted a
31:27 unique reservation id key could be provided by the i2c module to the user
31:34 and the user must pass that id into apis
31:39 like i2c underscore read and this key could just be a counter that's incremented for every reservation
31:46 granted then the idea is the api functions would verify that the correct key is being
31:52 used or in other words the most recent key so only the user with that most recent key would be allowed access
32:03 for the second issue when a reservation is requested a maximum use time could be
32:09 provided by the user say 100 milliseconds so the user is saying i definitely will
32:14 not need the bus more than 100 milliseconds so then if the reservation is not released in that amount of time the i2c
32:23 module will automatically release it on its own i don't have a suggested improvement for
32:29 the third issue but of course some kind of queue could be created to allow users to request a reservation and then be
32:36 granted it in the order of the request maybe using a callback function
32:42 the thing about all this stuff you have to think about the purpose of the reservation scheme currently it was just
32:48 designed as a very simple way for users of the i2c module to perform their i2c
32:55 operations one at a time and not interfere with each other it was assumed everyone plays by the
33:01 rules so some of these ideas might be overkill but some might be very useful and make
33:08 the software more robust it comes down to engineering judgment
33:13 and it could also come down to how i2c is being used in your application
33:20 this concludes the implementation and demo part of the i2c driver module i hope it was helpful for you and once
33:27 again thanks for watching