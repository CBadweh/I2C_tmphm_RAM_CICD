/*
 * HAPPY PATH I2C DRIVER - Maximum Simplicity Version
 * 
 * ALL ABSTRACTIONS REMOVED - Every step is explicit and visible:
 * - No helper functions (start_op, op_stop_success)
 * - No error handling
 * - All code inlined for direct, linear reading
 * 
 * LEARNING PATH:
 * 1. Reserve/Release (resource sharing)
 * 2. Write/Read APIs (see entire flow in one place)
 * 3. State machine (7 states)
 * 4. Interrupt handler (drives state transitions, see cleanup inline)
 */

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stddef.h>

#include "stm32f4xx.h"
#include "stm32f4xx_ll_i2c.h"

#include "cmd.h"
#include "console.h"
#include "log.h"
#include "lwl.h"
#include "module.h"
#include "tmr.h"

#include "i2c.h"

////////////////////////////////////////////////////////////////////////////////
// MACROS - Interrupt control
////////////////////////////////////////////////////////////////////////////////

#define INTERRUPT_ENABLE_MASK (LL_I2C_CR2_ITEVTEN | LL_I2C_CR2_ITBUFEN | \
                               LL_I2C_CR2_ITERREN)
#define INTERRUPT_ERR_MASK (I2C_SR1_BERR | I2C_SR1_ARLO | I2C_SR1_AF | \
                            I2C_SR1_OVR | I2C_SR1_PECERR | I2C_SR1_TIMEOUT | \
                            I2C_SR1_SMBALERT)
#define DISABLE_ALL_INTERRUPTS(st) st->i2c_reg_base->CR2 &= ~INTERRUPT_ENABLE_MASK
#define ENABLE_ALL_INTERRUPTS(st) st->i2c_reg_base->CR2 |= INTERRUPT_ENABLE_MASK

////////////////////////////////////////////////////////////////////////////////
// LWL IDs - For documentation (actual IDs auto-generated by __COUNTER__)
////////////////////////////////////////////////////////////////////////////////

#define LWL_RESERVE     0   // Reserve called
#define LWL_RELEASE     1   // Release called  
#define LWL_WRITE       2   // Write started
#define LWL_READ        3   // Read started
#define LWL_OP_SUCCESS  4   // Operation succeeded
#define LWL_OP_FAIL     5   // Operation failed
#define LWL_TIMEOUT     6   // Guard timer fired
#define LWL_ERR_INT     7   // Error interrupt (future use)

////////////////////////////////////////////////////////////////////////////////
// STATE MACHINE - The heart of the driver
////////////////////////////////////////////////////////////////////////////////

enum states {
    STATE_IDLE,                     // Ready for new operation
    STATE_MSTR_WR_GEN_START,        // Write: Generating START condition
    STATE_MSTR_WR_SENDING_ADDR,     // Write: Sending address + W bit
    STATE_MSTR_WR_SENDING_DATA,     // Write: Sending data bytes
    STATE_MSTR_RD_GEN_START,        // Read: Generating START condition
    STATE_MSTR_RD_SENDING_ADDR,     // Read: Sending address + R bit
    STATE_MSTR_RD_READING_DATA,     // Read: Receiving data bytes
};

enum interrupt_type {
    INTER_TYPE_EVT,                 // Event interrupt
    INTER_TYPE_ERR,                 // Error interrupt
};

// Performance measurements for i2c
enum i2c_u16_pms {
    CNT_RESERVE_FAIL,
    CNT_BUS_BUSY,
    CNT_GUARD_TMR,
    CNT_PEC_ERR,
    CNT_TIMEOUT,
    CNT_ACK_FAIL,
    CNT_BUS_ERR,
    CNT_INTR_UNEXPECT,

    NUM_U16_PMS
};

////////////////////////////////////////////////////////////////////////////////
// STATE STRUCTURE - Holds all info for one I2C instance
////////////////////////////////////////////////////////////////////////////////

struct i2c_state {
    struct i2c_cfg cfg;             // Configuration
    I2C_TypeDef* i2c_reg_base;      // Hardware registers (I2C3)
    int32_t guard_tmr_id;           // Timer ID (unused in happy path)
    
    uint8_t* msg_bfr;               // Data buffer
    uint32_t msg_len;               // Total bytes to transfer
    uint32_t msg_bytes_xferred;     // Bytes transferred so far
    
    uint16_t dest_addr;             // Slave address
    
    bool reserved;                  // Is bus reserved?
    enum states state;              // Current state
    enum i2c_errors last_op_error;  // Last operation error code
    enum states last_op_error_state; // State when error occurred
};

////////////////////////////////////////////////////////////////////////////////
// PRIVATE FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

static int32_t start_op(enum i2c_instance_id instance_id,
                        uint32_t dest_addr,
                        uint8_t* msg_bfr,
                        uint32_t msg_len,
                        enum states init_state);
static void i2c_interrupt(enum i2c_instance_id instance_id,
                          enum interrupt_type inter_type,
                          IRQn_Type irq_type);
static void op_stop_success(struct i2c_state* st, bool set_stop);
static void op_stop_fail(struct i2c_state* st, enum i2c_errors error,
                         enum i2c_u16_pms pm);
static enum tmr_cb_action guard_tmr_callback(int32_t tmr_id, uint32_t user_data);

static int32_t cmd_i2c_status(int32_t argc, const char** argv);
static int32_t cmd_i2c_test(int32_t argc, const char** argv);

////////////////////////////////////////////////////////////////////////////////
// PRIVATE VARIABLES
////////////////////////////////////////////////////////////////////////////////

static struct i2c_state i2c_states[I2C_NUM_INSTANCES];

static int32_t log_level = LOG_DEBUG;

// Storage for performance measurements.
static uint16_t cnts_u16[NUM_U16_PMS];

// Names of performance measurements.
static const char* cnts_u16_names[NUM_U16_PMS] = {
    "i2c reserve fail",
    "i2c bus busy",
    "i2c guard tmr",
    "i2c pec",
    "i2c timeout",
    "i2c ack fail",
    "i2c bus error",
    "i2c unexpect intr",
};

// Data structure with console command info.
static struct cmd_cmd_info cmds[] = {
    {
        .name = "status",
        .func = cmd_i2c_status,
        .help = "Get module status, usage: i2c status",
    },
    {
        .name = "test",
        .func = cmd_i2c_test,
        .help = "Run test, usage: i2c test [<op> [<arg>]] (enter no op for help)",
    }
};

// Data structure passed to cmd module for console interaction.
static struct cmd_client_info cmd_info = {
    .name = "i2c",
    .num_cmds = ARRAY_SIZE(cmds),
    .cmds = cmds,
    .log_level_ptr = &log_level,
    .num_u16_pms = NUM_U16_PMS,
    .u16_pms = cnts_u16,
    .u16_pm_names = cnts_u16_names,
};

////////////////////////////////////////////////////////////////////////////////
// PUBLIC API FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

/*
 * Get default configuration
 */
int32_t i2c_get_def_cfg(enum i2c_instance_id instance_id, struct i2c_cfg* cfg)
{
    cfg->transaction_guard_time_ms = CONFIG_I2C_DFLT_TRANS_GUARD_TIME_MS;
    return 0;
}

/*
 * Initialize I2C instance - Called once at startup
 */
int32_t i2c_init(enum i2c_instance_id instance_id, struct i2c_cfg* cfg)
{
    struct i2c_state* st;

    if (instance_id >= I2C_NUM_INSTANCES)
        return MOD_ERR_BAD_INSTANCE;

    if (cfg == NULL)
        return MOD_ERR_ARG;

    st = &i2c_states[instance_id];
    memset(st, 0, sizeof(*st));
    st->cfg = *cfg;

    switch (instance_id) {
        case I2C_INSTANCE_3:
            st->i2c_reg_base = I2C3;
            break;

        default:
            return MOD_ERR_BAD_INSTANCE;
    }
    return 0;
}

/*
 * Start I2C instance - Enable interrupts
 */
int32_t i2c_start(enum i2c_instance_id instance_id)
{
    struct i2c_state* st;
    int32_t result;

    if (instance_id >= I2C_NUM_INSTANCES ||
        i2c_states[instance_id].i2c_reg_base == NULL)
        return MOD_ERR_BAD_INSTANCE;

    // Register console commands
    result = cmd_register(&cmd_info);
    if (result < 0) {
        log_error("i2c_start: cmd error %d\n", result);
        return result;
    }

    st = &i2c_states[instance_id];

    // Get a timer with callback (Day 3: Guard timer protection)
    st->guard_tmr_id = tmr_inst_get_cb(0, guard_tmr_callback, (uint32_t)instance_id);
    if (st->guard_tmr_id < 0)
        return MOD_ERR_RESOURCE;

    // Disable peripheral and interrupts initially
    LL_I2C_Disable(st->i2c_reg_base);
    DISABLE_ALL_INTERRUPTS(st);

    // Enable I2C3 event interrupt in NVIC
    NVIC_SetPriority(I2C3_EV_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
    NVIC_EnableIRQ(I2C3_EV_IRQn);

    // Enable I2C3 error interrupt in NVIC (Day 2)
    NVIC_SetPriority(I2C3_ER_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
    NVIC_EnableIRQ(I2C3_ER_IRQn);

    return 0;
}

/*
 * Run function - Does nothing
 */
int32_t i2c_run(enum i2c_instance_id instance_id)
{
    return 0;
}

/*
 * RESERVE BUS - Get exclusive access
 * 
 * Returns: 0 on success, error code on failure
 */
int32_t i2c_reserve(enum i2c_instance_id instance_id)
{
    // Validate instance ID
    if (instance_id >= I2C_NUM_INSTANCES)
        return MOD_ERR_BAD_INSTANCE;
    
    struct i2c_state* st = &i2c_states[instance_id];
    
    // Log reserve attempt
    LWL("inst=%d reserved=%d", 2, LWL_1(instance_id), LWL_1(st->reserved));
    
    // Check if already reserved
    if (st->reserved) {
        INC_SAT_U16(cnts_u16[CNT_RESERVE_FAIL]);
        return MOD_ERR_RESOURCE_NOT_AVAIL;
    }
    
    st->reserved = true;
    return 0;  // Success
}

/*
 * RELEASE BUS - Free for others to use
 * 
 * Returns: 0 on success, error code on failure
 */
int32_t i2c_release(enum i2c_instance_id instance_id)
{
    // Validate instance ID
    if (instance_id >= I2C_NUM_INSTANCES)
        return MOD_ERR_BAD_INSTANCE;
    
    // Log release
    LWL("inst=%d", 1, LWL_1(instance_id));
    
    i2c_states[instance_id].reserved = false;
    return 0;  // Success
}

/*
 * WRITE - Start write operation (NO HELPER FUNCTIONS - all inline)
 * 
 * You can read the ENTIRE write setup in one place:
 * 1. Validate parameters and state
 * 2. Save parameters (address, buffer, length)
 * 3. Set state to WR_GEN_START
 * 4. Enable peripheral
 * 5. Generate START
 * 6. Enable interrupts
 * 
 * Then the interrupt handler takes over (see i2c_interrupt below)
 * 
 * Returns: 0 on success (operation started), error code on failure
 */
int32_t i2c_write(enum i2c_instance_id instance_id, uint32_t dest_addr, 
                  uint8_t* msg_bfr, uint32_t msg_len)
{
    return start_op(instance_id, dest_addr, msg_bfr, msg_len,
                    STATE_MSTR_WR_GEN_START);
}

/*
 * READ - Start read operation (NO HELPER FUNCTIONS - all inline)
 * 
 * You can read the ENTIRE read setup in one place:
 * 1. Validate parameters and state
 * 2. Save parameters (address, buffer, length)
 * 3. Set state to RD_GEN_START
 * 4. Enable peripheral
 * 5. Generate START
 * 6. Enable interrupts
 * 
 * Then the interrupt handler takes over (see i2c_interrupt below)
 * 
 * Returns: 0 on success (operation started), error code on failure
 */
int32_t i2c_read(enum i2c_instance_id instance_id, uint32_t dest_addr,
                 uint8_t* msg_bfr, uint32_t msg_len)
{
    return start_op(instance_id, dest_addr, msg_bfr, msg_len,
                    STATE_MSTR_RD_GEN_START);
}

/*
 * GET STATUS - Poll this to check if operation complete
 * 
 * Returns: 
 *   0 = operation complete and succeeded
 *   MOD_ERR_OP_IN_PROG = still working
 *   MOD_ERR_FAIL = operation complete but failed (use i2c_get_error for details)
 *   MOD_ERR_BAD_INSTANCE = invalid instance_id
 */
int32_t i2c_get_op_status(enum i2c_instance_id instance_id)
{
    // Validate instance ID
    if (instance_id >= I2C_NUM_INSTANCES)
        return MOD_ERR_BAD_INSTANCE;
    
    struct i2c_state* st = &i2c_states[instance_id];
    
    if (st->state != STATE_IDLE)
        return MOD_ERR_OP_IN_PROG;  // Still working
    
    // Operation complete - check if succeeded
    if (st->last_op_error == I2C_ERR_NONE)
        return 0;  // Success
    else
        return MOD_ERR_FAIL;  // Failed
}

/*
 * GET ERROR - Get detailed error code from last operation
 * 
 * Call this after i2c_get_op_status() returns MOD_ERR_FAIL to get
 * the specific I2C error that occurred.
 * 
 * Returns: I2C-specific error code (see enum i2c_errors)
 */
enum i2c_errors i2c_get_error(enum i2c_instance_id instance_id)
{
    if (instance_id >= I2C_NUM_INSTANCES)
        return I2C_ERR_INVALID_INSTANCE;
    
    return i2c_states[instance_id].last_op_error;
}

////////////////////////////////////////////////////////////////////////////////
// INTERRUPT HANDLERS
////////////////////////////////////////////////////////////////////////////////

void I2C3_EV_IRQHandler(void)
{
    i2c_interrupt(I2C_INSTANCE_3, INTER_TYPE_EVT, I2C3_EV_IRQn);
}

void I2C3_ER_IRQHandler(void)
{
    i2c_interrupt(I2C_INSTANCE_3, INTER_TYPE_ERR, I2C3_ER_IRQn);
}

////////////////////////////////////////////////////////////////////////////////
// INTERRUPT HANDLER - THE HEART OF THE DRIVER
// 
// NO HELPER FUNCTIONS - all cleanup code inlined directly where it happens
// You can see the COMPLETE flow for each state in one place
////////////////////////////////////////////////////////////////////////////////

static void i2c_interrupt(enum i2c_instance_id instance_id,
                          enum interrupt_type inter_type,
                          IRQn_Type irq_type)
{
    struct i2c_state* st;
    uint16_t sr1;

    if (instance_id >= I2C_NUM_INSTANCES)
        return;

    st = &i2c_states[instance_id];

    // If instance is not initialized, we should not get an interrupt, but for
    // safety just disable it.
    if (st->i2c_reg_base == NULL) {
        NVIC_DisableIRQ(irq_type);
        return;
    }

    sr1 = st->i2c_reg_base->SR1;  // Read status

    log_trace("i2c_interrupt state=%d xferred=%lu sr1=0x%04x\n", st->state,
                st->msg_bytes_xferred, sr1);

    // ===== ERROR INTERRUPT HANDLER (Day 2) =====
    if (inter_type == INTER_TYPE_ERR) {
        // Classify the error
        enum i2c_errors i2c_error;
        enum i2c_u16_pms pm;
        
        if (sr1 & I2C_SR1_AF) {
            i2c_error = I2C_ERR_ACK_FAIL;  // Slave didn't ACK
            pm = CNT_ACK_FAIL;
        } else if (sr1 & I2C_SR1_BERR) {
            i2c_error = I2C_ERR_BUS_ERR;   // Bus error
            pm = CNT_BUS_ERR;
        } else if (sr1 & I2C_SR1_ARLO) {
            i2c_error = I2C_ERR_BUS_ERR;   // Arbitration lost
            pm = CNT_BUS_ERR;
        } else if (sr1 & I2C_SR1_PECERR) {
            i2c_error = I2C_ERR_PEC;       // PEC error
            pm = CNT_PEC_ERR;
        } else if (sr1 & I2C_SR1_TIMEOUT) {
            i2c_error = I2C_ERR_TIMEOUT;   // Timeout
            pm = CNT_TIMEOUT;
        } else if (sr1 & I2C_SR1_OVR) {
            i2c_error = I2C_ERR_INTR_UNEXPECT;  // Overrun
            pm = CNT_INTR_UNEXPECT;
        } else if (sr1 & I2C_SR1_SMBALERT) {
            i2c_error = I2C_ERR_INTR_UNEXPECT;  // SMBus alert
            pm = CNT_INTR_UNEXPECT;
        } else {
            i2c_error = I2C_ERR_INTR_UNEXPECT;  // Unknown
            pm = CNT_INTR_UNEXPECT;
        }
        
        // Clear error flags (required by hardware!)
        st->i2c_reg_base->SR1 &= ~(sr1 & INTERRUPT_ERR_MASK);
        
        // Abort operation and clean up
        op_stop_fail(st, i2c_error, pm);
        return;
    }

    // ===== EVENT INTERRUPT HANDLER (Day 1 + Day 3 LWL) =====
    switch (st->state) {
    
        // ===== WRITE SEQUENCE: 3 States =====
        
        case STATE_MSTR_WR_GEN_START:
            LWL("I2C: WR_GEN_START", 0);
            // HW sent START? Check SB (Start Bit) flag
            if (sr1 & LL_I2C_SR1_SB) {
                LWL("I2C: START sent, sending addr=0x%02x", 1, LWL_1(st->dest_addr));
                // Send 7-bit address + W bit (0)
                st->i2c_reg_base->DR = st->dest_addr << 1;
                st->state = STATE_MSTR_WR_SENDING_ADDR;
            }
            break;

        case STATE_MSTR_WR_SENDING_ADDR:
            LWL("I2C: WR_SENDING_ADDR", 0);
            // Slave ACKed the address?
            if (sr1 & LL_I2C_SR1_ADDR) {
                LWL("I2C: Addr ACKed, starting data transfer", 0);
                (void)st->i2c_reg_base->SR2;  // Clear ADDR flag
                
                // Start sending data bytes
                st->state = STATE_MSTR_WR_SENDING_DATA;
                st->i2c_reg_base->DR = st->msg_bfr[st->msg_bytes_xferred++];
            }
            break;

        case STATE_MSTR_WR_SENDING_DATA:
            LWL("I2C: WR_SENDING_DATA byte=%d", 1, LWL_1(st->msg_bytes_xferred));
            // HW ready for next byte?
            if (sr1 & (LL_I2C_SR1_TXE | LL_I2C_SR1_BTF)) {
                
                if (st->msg_bytes_xferred < st->msg_len) {
                    // More bytes to send
                    st->i2c_reg_base->DR = st->msg_bfr[st->msg_bytes_xferred++];
                    
                } else if (sr1 & LL_I2C_SR1_BTF) {
                    // All bytes sent → DONE! Clean up with helper
                    LWL("I2C: Write complete, all bytes sent", 0);
                    op_stop_success(st, true);
                }
            }
            break;

        // ===== READ SEQUENCE: 3 States =====
        
        case STATE_MSTR_RD_GEN_START:
            LWL("I2C: RD_GEN_START", 0);
            // HW sent START?
            if (sr1 & LL_I2C_SR1_SB) {
                LWL("I2C: START sent, sending addr=0x%02x with R bit", 1, LWL_1(st->dest_addr));
                // Send 7-bit address + R bit (1)
                st->i2c_reg_base->DR = (st->dest_addr << 1) | 1;
                st->state = STATE_MSTR_RD_SENDING_ADDR;
            }
            break;

        case STATE_MSTR_RD_SENDING_ADDR:
            LWL("I2C: RD_SENDING_ADDR", 0);
            // Slave ACKed the address?
            if (sr1 & LL_I2C_SR1_ADDR) {
                LWL("I2C: Addr ACKed, configuring for %d byte read", 1, LWL_1(st->msg_len));
                // Set ACK/NACK mode
                if (st->msg_len == 1) {
                    LL_I2C_AcknowledgeNextData(st->i2c_reg_base, LL_I2C_NACK);
                } else {
                    LL_I2C_AcknowledgeNextData(st->i2c_reg_base, LL_I2C_ACK);
                }
                
                (void)st->i2c_reg_base->SR2;  // Clear ADDR flag
                
                // For single byte: generate STOP early
                if (st->msg_len == 1) {
                    LL_I2C_GenerateStopCondition(st->i2c_reg_base);
                }
                
                st->state = STATE_MSTR_RD_READING_DATA;
            }
            break;

        case STATE_MSTR_RD_READING_DATA:
            LWL("I2C: RD_READING_DATA byte=%d", 1, LWL_1(st->msg_bytes_xferred));
            // HW received data?
            if (sr1 & LL_I2C_SR1_RXNE) {
                // Read byte from DR register
                st->msg_bfr[st->msg_bytes_xferred++] = st->i2c_reg_base->DR;
                
                if (st->msg_bytes_xferred >= st->msg_len) {
                    // All bytes received → DONE! Clean up with helper
                    LWL("I2C: Read complete, all bytes received", 0);
                    bool send_stop = (st->msg_len > 1);
                    op_stop_success(st, send_stop);
                } else if (st->msg_bytes_xferred == st->msg_len - 1) {
                    // Next byte is the last one → NACK it and send STOP
                    LWL("I2C: Preparing for last byte, sending NACK", 0);
                    LL_I2C_AcknowledgeNextData(st->i2c_reg_base, LL_I2C_NACK);
                    LL_I2C_GenerateStopCondition(st->i2c_reg_base);
                }
            }
            break;

        default:
            break;
    }
}

////////////////////////////////////////////////////////////////////////////////
// ERROR CLEANUP HELPER - Day 2
////////////////////////////////////////////////////////////////////////////////

/*
 * FAILURE: Clean up and return to IDLE with error
 * 
 * This function is called when a hardware error occurs during an I2C operation.
 * It performs the necessary cleanup to prevent the state machine from getting stuck.
 * 
 * Steps:
 * 1. Disable all interrupts (prevent further interrupt firing)
 * 2. Send STOP condition (release the I2C bus)
 * 3. Disable the I2C peripheral
 * 4. Record the error code (so i2c_get_error() can report it)
 * 5. Return to IDLE state (ready for next operation)
 */
static void op_stop_fail(struct i2c_state* st, enum i2c_errors error,
                         enum i2c_u16_pms pm)
{
    // Log failure
    LWL("state=%d error=%d", 2, LWL_1(st->state), LWL_1(error));
    
    // Increment performance counter
    INC_SAT_U16(cnts_u16[pm]);
    
    // Disable all interrupts
    DISABLE_ALL_INTERRUPTS(st);
    
    // Cancel guard timer (Day 3)
    tmr_inst_start(st->guard_tmr_id, 0);
    
    // Always send STOP to release bus
    LL_I2C_GenerateStopCondition(st->i2c_reg_base);
    
    // Disable peripheral
    LL_I2C_Disable(st->i2c_reg_base);
    
    // Record error, error state, and return to IDLE
    st->last_op_error = error;
    st->last_op_error_state = st->state;
    st->state = STATE_IDLE;
}

static void op_stop_success(struct i2c_state* st, bool set_stop)
{
    // Log success
    LWL("state=%d xferred=%d", 3, LWL_1(st->state), LWL_2(st->msg_bytes_xferred));
    
    DISABLE_ALL_INTERRUPTS(st);

    if (set_stop) {
        LL_I2C_GenerateStopCondition(st->i2c_reg_base);
    }

    tmr_inst_start(st->guard_tmr_id, 0);

    LL_I2C_Disable(st->i2c_reg_base);

    st->state = STATE_IDLE;
    st->last_op_error = I2C_ERR_NONE;
}

////////////////////////////////////////////////////////////////////////////////
// GUARD TIMER CALLBACK - Day 3
////////////////////////////////////////////////////////////////////////////////

/*
 * Guard Timer Callback - Called by timer module if operation takes > 100ms
 * 
 * This callback is invoked by the timer module when an I2C operation exceeds
 * the guard time (typically 100ms). This catches the nightmare scenario where
 * the hardware completely fails to generate interrupts.
 * 
 * When this fires, we know something is seriously wrong (stuck bus, crashed
 * sensor, etc.) and we need to abort the operation to prevent the system
 * from hanging forever.
 * 
 * Parameters:
 *   tmr_id: Timer ID (not used in this simplified version)
 *   user_data: Contains the i2c_instance_id that we passed during registration
 * 
 * Returns: TMR_CB_NONE (one-shot timer, don't restart)
 */
static enum tmr_cb_action guard_tmr_callback(int32_t tmr_id, uint32_t user_data)
{
    enum i2c_instance_id instance_id = (enum i2c_instance_id)user_data;
    struct i2c_state* st = &i2c_states[instance_id];
    
    // Log timeout
    LWL("inst=%d state=%d", 2, LWL_1(instance_id), LWL_1(st->state));
    
    printc("TIMOUT\n");
    // Timeout occurred - abort operation with timeout error
    op_stop_fail(st, I2C_ERR_GUARD_TMR, CNT_GUARD_TMR);
    
    return TMR_CB_NONE;
}

static int32_t start_op(enum i2c_instance_id instance_id,
                        uint32_t dest_addr,
                        uint8_t* msg_bfr,
                        uint32_t msg_len,
                        enum states init_state)
{
    if (instance_id >= I2C_NUM_INSTANCES)
        return MOD_ERR_BAD_INSTANCE;

    struct i2c_state* st = &i2c_states[instance_id];

    if (!st->reserved)
        return MOD_ERR_NOT_RESERVED;

    if (st->state != STATE_IDLE)
        return MOD_ERR_STATE;

    if (LL_I2C_IsActiveFlag_BUSY(st->i2c_reg_base)) {
        INC_SAT_U16(cnts_u16[CNT_BUS_BUSY]);
        st->last_op_error = I2C_ERR_BUS_BUSY;
        st->last_op_error_state = STATE_IDLE;
        return MOD_ERR_PERIPH;
    }

    // Log operation start
    LWL("inst=%d addr=0x%02x len=%d state=%d", 5,
        LWL_1(instance_id), LWL_1(dest_addr), LWL_2(msg_len), LWL_1(init_state));

    tmr_inst_start(st->guard_tmr_id, st->cfg.transaction_guard_time_ms);

    st->dest_addr = dest_addr;
    st->msg_bfr = msg_bfr;
    st->msg_len = msg_len;
    st->msg_bytes_xferred = 0;
    st->last_op_error = I2C_ERR_NONE;
    st->last_op_error_state = STATE_IDLE;

    st->state = init_state;

    LL_I2C_Enable(st->i2c_reg_base);
    LL_I2C_GenerateStartCondition(st->i2c_reg_base);
    ENABLE_ALL_INTERRUPTS(st);

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// CONSOLE COMMAND FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

/*
 * @brief Console command function for "i2c status".
 *
 * @param[in] argc Number of arguments, including "i2c"
 * @param[in] argv Argument values, including "i2c"
 *
 * @return 0 for success, else a "MOD_ERR" value. See code for details.
 *
 * Command usage: i2c status
 */
static int32_t cmd_i2c_status(int32_t argc, const char** argv)
{
    uint32_t idx;
    struct i2c_state* st;

    printc("   Rsr Sta Dest Msg Byte I2C Err  Register\n"
           "ID vrd te  Addr Len Xfrd Err Sta  BaseAddr\n"
           "-- --- --- ---- --- ---- --- --- ----------\n");
    for (idx = 0, st = i2c_states; idx < I2C_NUM_INSTANCES; idx++, st++) {
        printc("%2lu %3d %3d 0x%02x %3lu %4lu %3d %3d %10p\n",
               idx, st->reserved, st->state, st->dest_addr, st->msg_len,
               st->msg_bytes_xferred, st->last_op_error,
               st->last_op_error_state, st->i2c_reg_base);
    }
    return 0;
}

/*
 * @brief Console command function for "i2c test".
 *
 * @param[in] argc Number of arguments, including "i2c"
 * @param[in] argv Argument values, including "i2c"
 *
 * @return 0 for success, else a "MOD_ERR" value. See code for details.
 *
 * Command usage: i2c test [<op> [<arg>]]
 */
static int32_t cmd_i2c_test(int32_t argc, const char** argv)
{
    struct cmd_arg_val arg_vals[5];
    int32_t rc = 0;
    int32_t idx;
#define MAX_MSG_LEN 7
    static uint32_t msg_len;
    enum i2c_instance_id instance_id = 0;
    static uint8_t msg_bfr[MAX_MSG_LEN];

    // Handle help case.
    if (argc == 2) {
        printc("Test operations and param(s) are as follows:\n"
               "  Reserve I2C, usage: i2c test reserve <instance-id>\n"
               "  Release I2C, usage: i2c test release <instance-id>\n");
        printc("  Start write, usage: i2c test write <instance-id> <addr> [<bytes> ...]\n"
               "  Start read, usage: i2c test read <instance-id> <addr> <num-bytes>\n"
               "  Get op status/error, usage: i2c test status <instance-id>\n");
        printc("  Bus busy, usage: i2c test busy <instance-id>\n"
               "  Print msg buffer, usage: i2c test msg <instance-id>\n");
        return 0;
    }

    // Get instance ID (except for msg option).
    if (strcasecmp(argv[2], "msg") != 0) {
        if (cmd_parse_args(argc-3, argv+3, "u+", arg_vals) != 1) {
            printc("Can't get instance ID\n");
            return MOD_ERR_BAD_CMD;
        }

        instance_id = (enum i2c_instance_id)arg_vals[0].val.u;
        if (instance_id >= I2C_NUM_INSTANCES ||
            i2c_states[instance_id].i2c_reg_base == NULL) {
            printc("Bad instance\n");
            return MOD_ERR_BAD_INSTANCE;
        }
    }

    if (strcasecmp(argv[2], "reserve") == 0) {
        rc = i2c_reserve(instance_id);
    } else if (strcasecmp(argv[2], "release") == 0) {
        rc = i2c_release(instance_id);
    } else if (strcasecmp(argv[2], "write") == 0) {
        rc = cmd_parse_args(argc-4, argv+4, "u[u[u[u[u]]]]", arg_vals);
        if (rc < 1) {
            return MOD_ERR_BAD_CMD;
        }
        for (idx = 1; idx < rc; idx++)
            msg_bfr[idx-1] = arg_vals[idx].val.u;
        rc = i2c_write(instance_id, arg_vals[0].val.u, msg_bfr, rc-1);
    } else if (strcasecmp(argv[2], "read") == 0) {
        rc = cmd_parse_args(argc-4, argv+4, "uu", arg_vals);
        if (rc < 2) {
            printc("Invalid command rc=%ld\n", rc);
            return MOD_ERR_BAD_CMD;
        }
        if (arg_vals[1].val.u > MAX_MSG_LEN) {
            printc("Message length limited to %d\n", MAX_MSG_LEN);
            return MOD_ERR_ARG;
        }
        msg_len = arg_vals[1].val.u;
        rc = i2c_read(instance_id, arg_vals[0].val.u, msg_bfr, msg_len);
    } else if (strcasecmp(argv[2], "status") == 0) {
        printc("op_status=%ld error=%d\n", i2c_get_op_status(instance_id),
               i2c_get_error(instance_id));
        goto done;
    } else if (strcasecmp(argv[2], "busy") == 0) {
        rc = i2c_bus_busy(instance_id);
    } else if (strcasecmp(argv[2], "msg") == 0) {
        for (idx = 0; idx < msg_len; idx++)
            printc("%02x ", msg_bfr[idx]);
        printc("\n");
    } else {
        printc("Invalid operation '%s'\n", argv[2]);
        return MOD_ERR_BAD_CMD;
    }
    printc("Return code %ld\n", rc);
done:
    return 0;
}

/*
 * @brief Check if I2C bus is busy.
 *
 * @param[in] instance_id Identifies the i2c instance.
 *
 * @return 1 if busy, 0 if not busy, else a "MOD_ERR" value. See code for details.
 */
int32_t i2c_bus_busy(enum i2c_instance_id instance_id)
{
    if (instance_id >= I2C_NUM_INSTANCES ||
        i2c_states[instance_id].i2c_reg_base == NULL)
        return MOD_ERR_BAD_INSTANCE;

    return LL_I2C_IsActiveFlag_BUSY(i2c_states[instance_id].i2c_reg_base) ? 1 : 0;
}

////////////////////////////////////////////////////////////////////////////////
// AUTOMATED TEST FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

/*
 * AUTOMATED TEST - Run button-triggered I2C test sequence
 * 
 * DAY 1: Now with complete error checking!
 * - Checks return values from all API calls
 * - Prints error messages with details
 * - Cleans up (releases bus) on failures
 * - Resets state machine on errors
 */
int32_t i2c_run_auto_test(void)
{
    enum i2c_instance_id instance_id = I2C_INSTANCE_3;
    static uint32_t test_state = 0;
    static uint32_t msg_len = 0;
    static uint8_t msg_bfr[7];
    int32_t rc;
    enum i2c_errors err;

    switch (test_state) {
        case 0:  // Reserve the I2C bus
            rc = i2c_reserve(instance_id);
            if (rc != 0) {
                printc("ERROR: Reserve failed (rc=%ld)\n", (long)rc);
                test_state = 0;  // Reset
                return 1;  // Test failed
            }
            printc("RESERVED\n");
            test_state = 1;
            return 0;  // Continue

        case 1:  // Write command to sensor
            msg_bfr[0] = 0x2c;  // High repeatability measurement
            msg_bfr[1] = 0x06;
            rc = i2c_write(instance_id, 0x44, msg_bfr, 2);
            if (rc != 0) {
                printc("ERROR: Write start failed (rc=%ld)\n", (long)rc);
                i2c_release(instance_id);  // Cleanup
                test_state = 0;  // Reset
                return 1;  // Test failed
            }
            printc("WRITE\n");
            test_state = 2;
            return 0;  // Continue

        case 2:  // Wait for write to complete
            rc = i2c_get_op_status(instance_id);
            if (rc == MOD_ERR_OP_IN_PROG)
                return 0;  // Still busy
            
            // Check if write succeeded
            if (rc != 0) {
                err = i2c_get_error(instance_id);
                printc("ERROR: Write failed (rc=%ld, err=%d)\n", (long)rc, err);
                i2c_release(instance_id);  // Cleanup
                test_state = 0;  // Reset
                return 1;  // Test failed
            }
            
            test_state = 3;
            return 0;  // Continue

        case 3:  // Read temperature/humidity data
            msg_len = 6;  // temp(2) + CRC + hum(2) + CRC
            rc = i2c_read(instance_id, 0x44, msg_bfr, msg_len);
            if (rc != 0) {
                printc("ERROR: Read start failed (rc=%ld)\n", (long)rc);
                i2c_release(instance_id);  // Cleanup
                test_state = 0;  // Reset
                return 1;  // Test failed
            }
            printc("READ\n");
            test_state = 4;
            return 0;  // Continue

        case 4:  // Wait for read to complete
            rc = i2c_get_op_status(instance_id);
            if (rc == MOD_ERR_OP_IN_PROG)
                return 0;  // Still busy
            
            // Check if read succeeded
            if (rc != 0) {
                err = i2c_get_error(instance_id);
                printc("ERROR: Read failed (rc=%ld, err=%d)\n", (long)rc, err);
                i2c_release(instance_id);  // Cleanup
                test_state = 0;  // Reset
                return 1;  // Test failed
            }
            
            test_state = 5;
            return 0;  // Continue

        case 5:  // Release the bus
            rc = i2c_release(instance_id);
            if (rc != 0) {
                printc("ERROR: Release failed (rc=%ld)\n", (long)rc);
                test_state = 0;  // Reset
                return 1;  // Test failed
            }
            printc("RELEASE - Test SUCCESS!\n");
            test_state = 0;  // Reset for next test
            return 1;  // Test complete

        default:
            test_state = 0;
            return 1;
    }
}

int32_t i2c_run_auto_test_timeout(void)
{
    enum i2c_instance_id instance_id = I2C_INSTANCE_3;
    static uint32_t test_state = 0;
    static uint8_t msg_bfr[2];
    static bool nvic_disabled = false;
    int32_t rc;
    enum i2c_errors err;

    switch (test_state) {
        case 0:  // Reserve the I2C bus
            rc = i2c_reserve(instance_id);
            if (rc != 0) {
                printc("FAULT: Reserve failed (rc=%ld)\n", (long)rc);
                test_state = 0;
                return 1;
            }
            printc("FAULT: RESERVED\n");
            test_state = 1;
            return 0;

        case 1:  // Start write and disable interrupts
            msg_bfr[0] = 0x2c;
            msg_bfr[1] = 0x06;
            rc = i2c_write(instance_id, 0x44, msg_bfr, 2);
            if (rc != 0) {
                printc("FAULT: Write start failed (rc=%ld)\n", (long)rc);
                i2c_release(instance_id);
                test_state = 0;
                return 1;
            }
            NVIC_DisableIRQ(I2C3_EV_IRQn);
            NVIC_DisableIRQ(I2C3_ER_IRQn);
            nvic_disabled = true;
            printc("FAULT: WRITE (interrupts disabled)\n");
            test_state = 2;
            return 0;

        case 2:  // Wait for guard timer to trigger
            rc = i2c_get_op_status(instance_id);
            if (rc == MOD_ERR_OP_IN_PROG)
                return 0;

            if (nvic_disabled) {
                NVIC_EnableIRQ(I2C3_EV_IRQn);
                NVIC_EnableIRQ(I2C3_ER_IRQn);
                nvic_disabled = false;
            }

            err = i2c_get_error(instance_id);
            if (rc == 0) {
                printc("FAULT: Timeout did not occur (rc=%ld, err=%d)\n", (long)rc, err);
            } else {
                printc("FAULT: Operation failed (rc=%ld, err=%d)\n", (long)rc, err);
            }

            i2c_release(instance_id);
            test_state = 0;
            return 1;

        default:
            if (nvic_disabled) {
                NVIC_EnableIRQ(I2C3_EV_IRQn);
                NVIC_EnableIRQ(I2C3_ER_IRQn);
                nvic_disabled = false;
            }
            test_state = 0;
            return 1;
    }
}
