00:01 in this lesson we discussed the design
00:03 and implementation of an i2c module for
00:06 a bare metal environment
00:07 at the end i do a demo using a low-cost
00:10 logic analyzer to see the signals on the
00:12 wire
00:14 now this is for a particular stm32mcu
00:18 so of course some of this lesson is
00:19 specific to that mcu but i try to keep
00:23 things more generic so hopefully it is
00:25 useful for anyone working with i2c
00:28 and i should point out that even stm32
00:31 mcus have several types of i2c
00:34 hardware
00:35 so the driver module i implemented for
00:37 this course would not work in all
00:40 stm32mcus
00:42 there's a lot of material so it's broken
00:44 up into two videos the first video is
00:47 requirements and design
00:49 and the second one is implementation
00:52 which is mainly code and the demo
00:56 so for this first part we start by
00:59 listing the requirements for
01:02 a minimum
01:03 viable product from my point of view
01:06 where in this case the product is the
01:08 driver module
01:09 then i go through some design tasks some
01:12 of the things i will spend time on are
01:16 some initial design decisions
01:18 some of these actually extend a little
01:20 bit into implementation
01:22 the api
01:24 and the state machine for both of the
01:27 videos i end with some prompts or
01:30 questions for you to try to answer for
01:32 each prompt i will give you a second to
01:34 pause the video if you want and then
01:36 give you my take on the prompt
01:39 now just for reference here are the
01:41 topics in the second video
01:43 i won't go through them now
01:47 so here is a list of what i consider the
01:48 minimum viable product requirements it's
01:51 nice to have a set of written
01:53 requirements even if it is just a simple
01:55 list like this sometimes on very small
01:58 projects it is assumed that everyone
02:00 knows the requirements and that can lead
02:02 to problems later on
02:04 so the systems i have in mind for this
02:06 driver module are boards with an mcu and
02:09 several i2c slave devices these devices
02:13 would be things like displays maybe some
02:15 double e prom memory or a sensor
02:19 now most of these requirements are
02:21 self-explanatory so i'll go through them
02:23 fairly quickly
02:25 one
02:27 master operation only and only a single
02:29 master
02:31 and of course that master would be the
02:32 mcu on the board
02:35 support of simple read-only and
02:37 write-only operations this means we
02:40 don't
02:41 support combined formats like a write
02:43 plus a read in a single i2c transaction
02:46 and about these combined formats some
02:48 slave devices support them but don't
02:51 require you to use them you can instead
02:53 just do a write and then a read
02:58 7-bit address support since 10-bit
03:02 addresses are rarely used now these
03:05 first three requirements are
03:07 i2c specific now we get into more
03:10 generic requirements and these are
03:13 requirements that are sometimes referred
03:15 to as non-functional because they are
03:17 internal requirements that are not
03:20 visible from the outside world
03:22 necessarily
03:25 so the first of those is to support
03:28 shared usage of an i2c bus between
03:31 multiple user modules
03:33 so if you have multiple slave i2c
03:36 devices you often have multiple software
03:39 modules
03:41 one for each type of device and there
03:43 has to be a way for these modules to
03:46 share the i2c interface since you can
03:48 only talk to one device at a time and
03:51 we'll see how that works later in this
03:52 lesson
03:54 then there are these generic
03:56 requirements for a super loop system the
03:58 module must support the standard core
04:01 api to interface to the super loop now
04:05 this core api is the one i developed for
04:07 the base mcu course and it's pretty
04:09 typical of super loop modules
04:13 and of course the module apis must be
04:16 non-blocking this is critical
04:19 finally we have some
04:21 requirements for test and debug i
04:23 consider this kind of thing essential
04:25 for real products that have to be
04:27 supported often the details of what is
04:30 needed are decided during the
04:32 development but after having done this
04:34 for a while you get a feeling for what
04:36 you're going to need
04:38 so a big one is the ability to perform
04:41 i2c transactions from the console
04:43 command line to try out different things
04:47 and we need performance measurements
04:50 to allow us to know how things are going
04:53 on the bus on long runs
04:55 now sometimes during development issues
04:57 come up and you need to modify or add
05:00 requirements to the list and that's just
05:02 the nature of product development
05:06 on this slide i list some of the major
05:08 design tasks from my point of view
05:10 probably everyone has a different way of
05:12 doing things but this is how i think
05:14 about it
05:15 and these are not exactly steps that are
05:17 executed in order it is iterative
05:20 and so you tend to move back and forth
05:23 as you make progress and learn more
05:25 so let's go through these
05:29 first you need a basic understanding of
05:30 the theory of operation this should go
05:32 without saying
05:33 now you don't have to be an expert to
05:35 start and i think i actually learn a lot
05:38 about the theory of operation when i
05:40 code a driver
05:43 next is reading the documentation for
05:45 the peripheral either in the data sheet
05:48 or the reference manual again this is
05:50 pretty obvious the thing is you tend to
05:53 look at it over and over again the first
05:55 time through there's probably a lot of
05:57 stuff you don't understand but hopefully
05:59 enough to get a start
06:01 as you make progress you go back and
06:03 re-read things and hopefully it makes a
06:05 little more sense i generally don't stop
06:08 looking at the reference manual until
06:09 i'm done with the driver and there still
06:11 might be a few things that i don't
06:13 completely understand
06:16 of course another task is
06:19 high level design decisions like what
06:22 the api is going to look at look like
06:24 whether or not to use dma and so on we
06:28 will look at these design decisions for
06:30 this driver shortly
06:31 often people don't write these decisions
06:33 down they just keep them in their heads
06:36 but it is good documentation especially
06:38 if you explain why you made the decision
06:40 you did
06:42 then of course there is the actual
06:44 design encoding this is things like
06:46 coming up with a state machine thinking
06:48 about any timers you might need and then
06:52 the coding and
06:54 i'm like i think a lot of people i
06:57 redo and refine the code again and again
07:00 sometimes i'll even add or remove
07:03 machine states from a state machine as i
07:06 learn more about the problem
07:09 and then finally there is
07:11 iterative testing and of course the idea
07:13 is to get code that you can test as
07:16 early as possible so for i2c you might
07:19 want to try to get
07:21 the code to
07:23 generate the start condition and try to
07:26 use that and see if you can see the
07:28 start condition with a logic analyzer
07:30 another thing i tend to want to get
07:32 early is interrupts i want it because
07:35 interrupts are often at the core of
07:38 these drivers so the earlier you get
07:40 interrupts occurring
07:42 the better the farther ahead you are
07:45 so i made this process sound organized
07:47 here but in reality i'm always jumping
07:50 all over the place
07:52 so one last resource i can't leave out
07:55 and that is other implementations for
07:58 this driver i was able to look at the
07:60 hell driver from time to time
08:03 i also looked at the linux driver there
08:05 happens to be a linux driver for this
08:07 exact i2c peripheral
08:09 and comparing it to the hell driver i'll
08:12 explain why i did that it was sort of a
08:14 special
08:16 situation
08:17 so
08:19 when you look at other drivers
08:20 especially things like linux drivers you
08:22 do have the problem of separating the
08:24 stuff that is sort of linux
08:28 boilerplate and overhead and finding the
08:31 core of the algorithms which is what you
08:34 really
08:35 want to see
08:39 on this slide i list some high-level
08:41 design and implementation decisions
08:44 ideally you make these decisions up
08:45 front but in reality it is iterative
08:49 so let's go through them
08:52 the driver will have a register
08:55 based design but will use the stm32 low
08:58 level or ll library to read and modify
09:02 registers
09:03 so here's why i use ll
09:06 al has done the menial grunt work for
09:09 reading and writing registers register
09:12 bits and register bit fields writing
09:14 your own code to access the raw
09:17 registers is something useful to do a
09:19 few times when first learning about
09:21 embedded but i would never do that
09:24 for the long term if you have an
09:25 alternative like ll
09:28 so what this means if you want to modify
09:31 a register bit or bit field you find the
09:34 ll api to do that normally it's just a
09:38 one line function or macro you might
09:41 want to look at the code for a few of
09:43 these just to see how they work
09:45 so the question comes up what if you
09:48 have to port this code to a non-stm32
09:52 part that uses exactly the same i2c
09:55 peripheral
09:57 my answer to that is simple if and when
09:59 you have to do that and often that is
10:01 never
10:02 you then you create some system of
10:05 wrappers it doesn't have to be that
10:07 eloquent it will be isolated within a
10:10 dot c file
10:14 next we will use interrupt based data
10:16 transfer at least to start dma support
10:20 could be added at a later time if we
10:22 need the performance
10:24 and what you will learn from
10:27 doing an interrupt based driver will be
10:29 very helpful if you move to dma there
10:31 will not be much wasted work
10:36 for now i will use the ide generated
10:39 code which will be ll-based
10:41 for i2c peripheral initialization
10:45 taking over this function and moving it
10:48 into the ied i2c driver module is a
10:50 future enhancement we will look at this
10:53 code and you'll see it's very simple it
10:55 just isn't worth it
10:57 to me
10:58 to take this
10:59 over right now
11:01 if and when that code gets
11:05 moved we could then add proper api
11:08 support for i2c initialization
11:10 configuration such as the bit rate
11:13 currently that's being set in the ide
11:17 next is the
11:19 high level api from the standpoint of
11:23 software that would use this module and
11:25 so here's what i came up with this is
11:27 based on past work
11:30 there will be an api to reserve an i2c
11:33 interface
11:34 then
11:35 initiate an i2c read or write operation
11:39 now with everything being non-blocking
11:41 this just kicks off the operation so you
11:44 need a way to know when the operation is
11:46 complete
11:48 and the way we do that is we have an api
11:51 to get the status of the read write
11:53 operation this will be a poll model the
11:55 alternative is a callback
11:58 for super loop
11:59 designs pull model is fine
12:03 and then finally at some point you would
12:05 release the i2c interface so that
12:07 another software module
12:09 could use it
12:12 and then the final thing here are some
12:14 i2 specific
12:16 console commands for test and debug
12:19 one is a command called i2c status which
12:23 just dumped some state information about
12:25 the module
12:26 and another one is called i2c test which
12:30 allows you to test the api and maybe do
12:33 a few other things to initiate i2c
12:36 procedures and test other kinds of use
12:39 cases
12:41 here is the header file for the i2c
12:43 module and i want to highlight just a
12:45 few things with the api
12:49 so here we see a new for the i2c
12:52 instance id
12:54 and this is sort of ugly because we have
12:56 all these config parameters that control
12:58 which i2c instances are going to be
13:00 supported
13:01 in the build
13:03 and by the way currently we only have
13:05 one i2c instance
13:07 instance three
13:09 here is the configuration
13:12 structure for this module
13:14 and the only configuration parameter now
13:17 is the transaction guard timer in
13:19 milliseconds
13:22 here are the core module apis that are
13:25 the interface to the module startup and
13:28 the super loop
13:31 and then these other apis are basically
13:33 the i2c
13:35 operations
13:36 so there are
13:38 apis to
13:40 reserve and release an i2c instance and
13:43 notice by the way that almost all these
13:45 apis take an instance id and then here
13:49 are the two apis to
13:52 kick off a read and kick off a write
13:54 operation
13:56 and then this api here is used to get
13:60 the status of that operation
14:02 as it's executing so
14:04 generally you expect either in progress
14:07 or completed successfully or completed
14:10 with error
14:12 and then there's a few other apis i
14:13 won't get into so this is the basic api
14:16 though for the module
14:19 on this slide i provide some information
14:21 on designing state machines like the one
14:23 for this i2c driver of course a lot has
14:26 been written on state machines and so
14:28 these are just some practical hints from
14:30 my point of view
14:31 so let's go through them
14:33 i tend to start
14:35 by just writing down the steps in a
14:38 procedure such as a read operation
14:40 now the states are often sort of the
14:43 natural waiting points in the flow of
14:45 the operation in those steps for example
14:48 waiting for an act after an address has
14:50 been sent
14:52 stands out as that is a state
14:55 now when in a state there are usually
14:57 expected events that will occur
15:00 for example an interrupt with a certain
15:02 status bit set that happens in a number
15:05 of cases for this i2c driver or a timer
15:08 expiring
15:11 now in addition to those expected events
15:13 are unexpected events and you need to
15:16 make sure you identify all those and so
15:18 those are things like interrupts with
15:20 error status bits set
15:22 or interrupts or events that seem
15:24 totally unexpected to what you're trying
15:26 to do
15:27 and then there are guard timers that
15:29 i'll mention in just a minute
15:31 so you have to determine how to handle
15:33 these unexpected events
15:36 handling some of these may be dependent
15:39 on the current state
15:41 but you really
15:42 want to avoid a lot of this if you can
15:45 so often we we try to have a common
15:48 method or a handler to handle most of
15:50 these errors
15:51 this error handling must be very robust
15:54 you want to make sure you clean things
15:56 up
15:57 in this driver for
15:59 most of the unexpected events i more or
16:02 less just generate a stop condition on
16:04 the bus and disable the hardware
16:09 you also need to consider the need for
16:11 guard timers to ensure the state machine
16:14 will never get stuck
16:15 sometimes
16:17 it's not clear you really need a
16:19 guard timer
16:21 i will add one if there is any doubt in
16:24 my mind
16:25 because i just want to be certain that
16:28 the procedures will always finish one
16:30 way or the other
16:32 now one simple approach is you just have
16:34 a single guard timer for an overall
16:36 procedure and that's what's done in this
16:38 module when a read operation starts we
16:41 start a guard timer and we stop it when
16:44 the read operation completes
16:45 successfully or unsuccessfully
16:50 now let's look at the state machine as
16:52 stated in this title this is a
16:54 simplified view the states shown here
16:57 are the actual states in the code but
16:59 the code has quite a bit more complexity
17:01 in the transitions
17:03 before we continue let me describe the
17:05 notation used in this state machine
17:07 diagram
17:08 so of course the blue boxes represent
17:10 the states
17:12 and between the states we see these
17:14 arrows that represent the transitions
17:16 for each transition the event that
17:18 triggers it
17:20 is shown in red in bold and is
17:22 underlined some of the events include a
17:25 condition like this one that must be
17:27 true for the transition to be made
17:30 below the event name is a set of actions
17:33 that are executed as part of the
17:35 transition
17:37 most of the events are the result of an
17:40 interrupt and they start with the word
17:42 interrupt colon
17:44 and there are two vents the these up
17:47 here that are
17:49 actually api function calls
17:51 so let's walk through the state machine
17:53 for an i2c read operation
17:56 first of all when the module is
17:57 initialized
17:59 it will enter the idle state as we see
18:02 here
18:03 next some software like another module
18:06 calls i2c
18:08 read
18:09 that api
18:10 from the list of actions you can see
18:12 that we enable the hardware we set the
18:14 start bit in control register one which
18:17 will generate a start condition
18:19 we set the variable for the number of
18:22 bytes to read or the number of bytes
18:24 left to read
18:25 and we start a guard timer i should
18:28 point out that the variables in the
18:30 state machine diagram do not necessarily
18:32 exist in the code sometimes you use
18:34 different variables in the diagram that
18:37 just make the logic easier to see
18:40 so we can see from the read generate
18:43 start
18:44 state that we will normally get an
18:47 interrupt with the sb
18:50 bit which is the start bit set this
18:52 tells us that the start condition has
18:54 been generated in response we write the
18:56 i2c address and the read write bit to
18:59 the i2c data register and then we wait
19:03 in the read sending address state
19:07 we expect an ack in response to that
19:09 address and if so we will get an
19:12 interrupt with the adder bit set
19:15 this drives us to the read
19:19 the reading data state in this state we
19:21 get a sequence of interrupts that say
19:23 that the i2c hardware has another
19:26 receive byte of data available
19:28 so we get that byte of data from the
19:31 data register and we put it in the
19:32 receive buffer
19:34 when we get near the
19:37 end of bytes to read
19:38 see here where we compare it to one
19:41 we have to clear the act bit in control
19:44 register one and set the stop bit this
19:47 will cause the last byte to be knacked
19:50 and then the stop condition to be
19:52 generated
19:54 so when we have read all of the bytes
19:57 except one right here we read that last
20:00 byte from the data register we cancel
20:03 the guard timer we disable the hardware
20:06 and we go back to idle we're done
20:09 now the process for a write operation is
20:12 very much the same so i won't go through
20:14 it
20:15 you also notice this transition down
20:17 here which is from any non-idle state it
20:20 handles
20:21 all of the unexpected interrupts
20:25 either error bits or just in general
20:27 unexpected events and it also handles
20:30 the guard timer expiring
20:32 and it's pretty simple
20:34 we first set the stop bit in control
20:36 register one to generate a stop
20:38 condition
20:39 then we cancel the guard timer
20:42 we disable hardware and we go back to
20:44 idle
20:46 so that's it for the state machine
20:48 i wanted to bring up one issue i ran
20:50 into with this module i call it special
20:52 instructions
20:54 i found that for this mcu and some
20:57 others the reference manual contains
20:60 what i call special instructions for
21:01 handling very short reads and the last
21:04 few bytes of a read transaction
21:07 and here is where you would find it in
21:09 the reference manual
21:11 now this information isn't important to
21:14 you really but it is an example of why
21:16 you need to read the reference manual
21:18 very carefully
21:20 i didn't notice these special
21:22 instructions at first
21:24 it looks like they were sort of added on
21:26 at the end and they are a little cryptic
21:29 and they even seem a little inconsistent
21:31 with the earlier text
21:33 so my initial implementation
21:36 did not use them and it worked okay and
21:39 so
21:40 i wonder do i really need to do this
21:44 but
21:46 i found that both the hell driver and
21:48 the linux driver implements these
21:50 special instructions and exactly the
21:52 same way
21:54 so i did that also even though my
21:57 implementation worked fine without them
21:60 i thought maybe they are needed for some
22:02 rare cases
22:05 here are the prompts for this video
22:07 lesson i'll pause here for a couple
22:10 seconds in case you want to pause the
22:12 video and look at them as a group on the
22:14 next set of slides i'll go through the
22:15 prompts one by one and reveal my take
22:21 what might the api look like to support
22:24 the combined format of write plus read
22:27 describe approaches to enhancing the
22:29 state machine to support this combined
22:31 format
22:36 well here's my take
22:38 for the api
22:40 all i did was say we have a write
22:43 an api to do a write an api to do a read
22:45 here's an api to do a write and a read
22:48 and the signature is pretty much the
22:50 same
22:51 with the difference being we have two
22:53 buffers and
22:55 two message lengths instead of one
22:57 otherwise it's pretty much the same
22:59 so
23:00 regarding the state machine
23:04 there are two options i thought of and
23:07 in general i would say when you're
23:09 enhancing a state machine you very often
23:12 have these two options so the first
23:14 option is let's create a new set of
23:16 states for write plus read
23:19 so we have read states we have write
23:21 states and then we would have right read
23:23 states and these states would pretty
23:25 much be independent of those existing
23:28 ones
23:30 another option is to say
23:33 why do we need to create all these new
23:35 states we already know how to do reads
23:37 and writes so in this case you would add
23:40 a flag or two
23:41 to the state state
23:44 data structure
23:45 to indicate that a write plus read was
23:48 in progress and you would reuse the
23:51 existing
23:52 read and write states so the way that
23:55 would work is
23:56 first you would do the right
23:58 part of the procedure using the right
24:01 states
24:03 but at the end of the write instead of
24:06 generating the stop condition like you
24:08 do now you would say oh we're doing a
24:10 write plus read so you would jump in to
24:13 start doing the read procedure using the
24:16 read states and when the read states the
24:18 procedure would finish normally
24:20 now
24:22 looking at this if i had to implement it
24:23 i would say i like option two because
24:25 it's probably less code less code
24:27 repetition
24:29 the only dangered option two
24:33 in general maybe not in this case but in
24:34 general is that when enhancing state
24:37 machines often people are reluctant to
24:39 add new states
24:41 and they start adding flags
24:44 and
24:45 sometimes you have to have a lot of
24:46 these flags
24:48 and what can happen in that case is
24:50 the states in the state machine
24:53 become
24:54 uh less clear what they really mean
24:57 because you have all this other you have
24:59 all this other information you know
25:01 stored as flags in a data structure and
25:03 at that point it becomes much more
25:06 difficult to or it can become much more
25:08 difficult to really understand the state
25:10 machine
25:14 might the api look like if callback
25:16 notification was used to indicate the
25:19 end of a read or a write operation would
25:22 new states be required
25:24 how would implementation of callback
25:25 notification for a reservation request
25:28 to be more complicated
25:34 well here's my take
25:36 first of all we got callback functions
25:38 when i work with callback functions
25:41 i always use a typedef for the callback
25:44 function and that's because uh function
25:47 pointers and c
25:49 are a little bit cryptic i i find and so
25:52 the typedef
25:54 sort of makes that clean you do the
25:55 typedef once and then there on you know
25:58 thereafter you just
25:59 use that typedef so here we're declaring
26:02 a type called i2c cb func for callback
26:06 function
26:08 and this function takes a
26:11 a uint some user data
26:13 which can be whatever the user wants it
26:15 to be
26:16 and uh and it returns void
26:19 and i have a comment that we might also
26:23 include the i2c instance as a parameter
26:27 the general idea behind this user data
26:29 is maybe this callback function is being
26:32 used for different scenarios so
26:34 when the callback function is made
26:36 the user makes use of this data to to
26:39 know what's going on
26:41 so then the effect of that on the api in
26:44 this in my very simple-minded way is the
26:47 i2c write function
26:49 uh i've added the uh the user passes
26:52 their callback function in here and then
26:54 they pass in whatever they want the user
26:56 data to be
26:57 and the same thing for the read
26:60 now as far as i know this wouldn't
27:01 require any new states
27:04 it's pretty straightforward
27:06 and
27:07 the question about callbacks for
27:09 reservation request why is that more
27:11 complicated i think it is and this is
27:14 sort of from an implementation viewpoint
27:16 it would be more complicated because you
27:18 can have multiple users trying to
27:20 reserve an i2c bus
27:23 for reads and writes my assumption is
27:25 only the user holding the reservation
27:27 can make a request so the module only
27:30 has to deal with one callback function
27:33 at a time whereas for reservations you
27:35 might have five users trying to get that
27:37 reservation so it's a matter of how do
27:40 you store those callback um
27:43 functions and and it's that that kind of
27:45 thing
27:48 this concludes the requirements and
27:50 design portion of the i2c driver module
27:53 i hope it was useful for you the next
27:55 video lesson goes into the code
27:57 implementation of the module and has a
27:60 demo using a low-cost logic analyzer
28:03 thanks for watching