00:00 in this video lesson we'll discuss the design and implementation of a software module for a temperature and humidity
00:07 sensor this sensor has an i2c interface and we'll be making use of the i2c module
00:13 from the previous lesson you can see the topics here and i'll just go through them quickly we start
00:20 with the requirements for this module which are not very long then we'll briefly look at the theory of
00:25 operation of the sensor by going through the data sheet we just look at a small part of the data sheet enough to
00:31 implement our requirements next we'll discuss some design decisions
00:37 and then the state machine design next we'll look at the module api which
00:43 is a dot h header file and uh we'll look at some of the
00:48 implementation which is the dot c file then i'll do a demo with the module including showing
00:56 a sort of nasty air case and as part of this demo we'll be using the logic
01:01 analyzer then after a brief summary i'll provide some prompts or questions for
01:07 you to try to answer for each prompt i'll give you a second to pause the video if you want and then give you my
01:13 take on the prompt so here are the requirements for the module the module name is temp hum
01:21 which stands for temperature humidity it's not a very clever clever name but at least it's not too long
01:28 what the module must do is perform background sampling of temperature and humidity using a sensarian
01:35 sht 31-d part the default sample rate is one second
01:41 it must do crc checking of the received sensor data as supported by the part
01:48 a crc is a method to verify the data is valid and we'll be discussing this later
01:54 it must also provide a non-blocking get api
01:60 for the latest sample value and the age of the sample so the idea is that any time a user of
02:05 this module can get the latest sample value the module does not support making a
02:10 measurement on demand although that could be a future feature
02:16 now it must support multiple of these sensors in the system and these
02:21 sensors might be on the same or different i2c buses and then finally it must provide test
02:29 and debug support and here i list the commands that i commonly implement for this kind of thing
02:34 we'll be using some of these commands as part of the demo so i'll just pause the video for a
02:40 second in case you want to read through them
02:46 so this is the data sheet for the temperature and humidity sensor and this is where we will find the theory of
02:51 operation now i'm just going to show you a few things in this document that are
02:57 relevant to the implementation of the temp hum module and so i'll be jumping around but i did read through this entire
03:04 document myself as i would if i were doing this work for my job and i encourage you to look at it
03:10 also there are a lot of things that can be done with this sensor over the i2c bus that i don't cover in this lesson
03:17 so first i'm going to go to table 7
03:23 right here this table shows how the i2c address is
03:29 controlled by the adder input pin if the pin is low the address is hex 44
03:37 if the pin is high the address is hex 45. now i have nothing connected to that pin but the schematic of the adafruit
03:44 board shows a pull down resistor so the address will be hex 44
03:50 and as you can see here the chip is not very flexible regarding i2c addressing
03:56 and this is how we can run into address conflicts now on that table 8 on page 10 which
04:04 shows the commands to do a one-shot measurement we'll use one-shot measurements in temp
04:10 hm now the command consists of two bytes the most significant byte and the least
04:16 significant byte first of all you might notice that there are different commands for different
04:22 levels of repeatability when you're working with sensors there are terms like accuracy precision
04:29 repeatability and others these are important concepts to understand but they're outside the scope of this course
04:36 so i encourage you to learn about them yourself the command bytes also determine whether
04:42 clock stretching is enabled or disabled and we'll see how that works in just a second
04:48 so down here you see some message sequences for sending a command and
04:56 reading this response so in this first line we send the command there's the address and then the
05:02 two bytes of the command and notice here is a start condition and
05:07 here is a stop condition so this is a complete transaction
05:13 now what this diagram shows us is reading the measurement and the assumption is
05:19 that you will be reading it before the measurement is complete so
05:25 it starts by sending the i2c address and then there are two cases
05:32 whether or not you have clock stretching enabled in this first case here you
05:37 don't have clock stretching enabled so what the device does is just snacks the
05:43 address and that sounds a little cold to me but that's what it does anyhow the idea
05:51 is you would try again later and let's say at this point the measurement is done and so now it will
05:58 act the address and then it'll continue on to do the read now let's look at the second case
06:04 where clock stretching is enabled so what happens here is it does act the address but then the device pulls the
06:11 clock line low which is known as clock stretching the master will notice that and it will
06:17 just wait and then when the measurement is done the
06:23 sensor will release the clock the master being the mcu will notice that and will
06:30 continue on now in the temp hum module we actually
06:35 put a delay after sending the command to attempt to avoid either of these
06:41 scenarios but just in case for some reason the measurement is isn't
06:46 ready we choose a command that enables clock stretching because clock
06:52 stretching doesn't really require the software to do anything the the i2c bus hardware takes care of this
06:59 clock stretching so let's now go to the actual data and there are
07:04 six bytes you'll notice there are two temperature bytes there are two humidity
07:10 bytes and then for each of these pairs there is a crc
07:15 byte which we'll talk about now so here i am at table 19
07:22 which is on page 14. and this table contains information about the crc
07:27 calculation so the idea is that you take your data bytes run them through a crc calculation
07:34 and see if the result matches the crc in the message if there is a match
07:40 it means that there is a very high probability that the date that the data bytes are valid that there was no error
07:48 when getting the data over the bus if the crc bytes don't match you
07:53 definitely have a problem so the crc calculation is based on a lot of theory and it's designed to detect as
08:00 many error cases as possible i won't go into that but you might want to do some more reading on it
08:07 now fortunately it's easy to find c code to compute crcs and find this code on
08:13 the web the table sort of contains input parameters for
08:18 that code and we'll look at the crc calculation code later in this lesson
08:27 another key piece of information is how to take those raw data bytes and convert them
08:33 into something meaningful and these are the formulas to do that both for the amount you relative
08:39 humidity and the temperature either in degrees c or degrees f
08:47 these calculations look pretty straightforward now with embedded you often want to avoid
08:54 floating point and so if you do these calculations with integers you do have to be careful of
09:01 the order of operations so you don't lose resolution finally i'm at table four on page five
09:09 this table contains the measurement duration for the different levels of repeatability
09:15 and you can see that the highest value is 15 milliseconds for high
09:21 repeatability so we will wait that long after sending a command to the sensor before trying to
09:28 read the result here i discussed design decisions for
09:33 temp hom and there is really just one and this one might be obvious that the
09:39 temp hum module will use the i2c module for communication with the sensor i mean
09:44 why would have i written the i2c module if i wasn't going to use it so what i'm doing here is highlighting the
09:50 advantages of this layered approach now the big thing is the i2c module
09:58 hides the complexity of i2c from the temp hum module next the i2c module provides hardware
10:06 abstraction and thus makes temp hum more portable the idea is if we move the software to
10:13 another mcu then the i2c module would likely need modification to support
10:19 different i2c hardware but this temp hum module wouldn't or shouldn't require change
10:27 next the i2c module allows sharing the i2c bus with other modules via this
10:33 reservation scheme so if we had a display with an i2c interface
10:38 and that display was on the same bus and if there was a software module for
10:45 the display like tempum then the two modules could each use the bus without being aware of each other
10:54 finally the i2c module has some test and debug features that would help during temp hum
11:00 development and support so here is the state machine for tempum
11:06 as with the state machine for the i2c module this is a simplified view and not
11:11 all of the error transitions are shown so i came up with this by just going
11:17 through the steps of what is needed to do a measurement cycle and what we do is send a command to the
11:23 sensor we wait a short time and then we read the result from this from the sensor
11:29 now if you remember the i2c state machine events were largely based on
11:34 interrupts this is not the case for this module let's go through the events
11:39 so there is a start measurement periodic timer event this is a timer callback and
11:45 it tells us it's time to do the next measurement all the rest of these events involve polling
11:51 and polling is a common thing to do in a super lot loop design and if the pulling overhead is low it's
11:58 perfectly fine so the way we achieve polling in this module is that the super loop
12:05 will be calling the modules run function and each time the run function is called
12:11 the module will do whatever check it needs to do so the outcome of calling i2c reserve is
12:20 an event as well as the result of calling i2c get op status and finally there is
12:26 an event based on a simple time calculation where we are waiting for the sensor to perform a measurement
12:34 so let's see how this works we start in idle and from here the
12:39 periodic timer expires that tells us to start a new measurement this moves us to
12:45 the reserve i2c state where of course we want to reserve
12:50 the interface so each time through the super loop we will call i2c reserve
12:57 if it fails presumably because there's another module using the interface
13:03 we stay in this state but if we get the reservation
13:09 which is the success case we then call i2c right
13:14 with the command that performs a single shot measurement and we move to the right measures command state
13:21 in write mesh command we call i2c get op status to check on the right operation
13:27 if we get an in progress result we stay in the state if we get a failure we go back to idle
13:34 we'll try again next time but we hope that we'll get a success
13:40 and in this case we record the time which is the beginning of the
13:46 measurement and we move to the weight measurement state so in weight weight mesh state we calculate how long
13:53 we've been there as discussed previously we should wait 15 milliseconds to be certain the
13:59 measurement is done when that time is up we call i2c read
14:06 to read the measurement data so the read measurement
14:11 value state is a lot like write measurement command as we keep checking the status of the operation and i'll
14:18 just focus on the success case this time in that case
14:24 assuming the crc is good in the measurement data we save the measurement value as the last measurement
14:31 and that brings us back to idle and you might have noticed that before we return to the idle state we always
14:38 release the i2c interface now i'd like to say a few things about
14:44 guard timers and error handling now in this state machine
14:49 i don't have any guard timers as you might remember the i2c module has
14:56 guard timers and i should be able to depend on those for any cases where we are waiting for
15:03 an i2c operation to finish now you could say
15:08 i don't trust the i2c module and i'm going to have my own guard timer that is engineering judgment and it might be the
15:14 correct approach where every module needs to look after itself
15:20 another thing you might think about the start measurement timer callback is
15:26 periodic and it will continue to expire even if the state machine is stuck
15:32 so if we get that callback event in a non-idle state we will know we are stuck so we could
15:39 sort of use that as a guard timer although the duration might be longer than what you want
15:45 now besides guard timers there is the more general issue of continuous measurement failures
15:52 so perhaps there is a threshold on the amount of time without a successful measurement
15:59 the most difficult part of these questions is not how you implement the detection mechanism but what to do when
16:07 it happens let's look at some possibilities you could print warning messages and keep
16:14 going no one's going to see that in the field you could send an alarm to a management
16:19 or monitoring system if applicable of course a lot of
16:24 systems don't have monitoring or management systems to get a little bit more proactive you
16:31 could try to reset the sensor chip from your software and maybe reset the i2c
16:37 bus that might clear it up and then usually the most drastic thing is you reset the mcu and often uh the
16:46 hardware design is such that this results in a reset of all the board
16:51 hardware including the sensor chip now what we should do depends on a lot
16:58 of things about what the product does uh how important that temperature or humidity measurement
17:06 is and so forth if you think this is a rare scenario the board reset choice is often used because
17:13 it's simple and if anything is going to fix the problem that should fix it and we sometimes call
17:20 that using the big hammer or we might say go big or go home so my experience is that you spend a lot
17:28 of time on this kind of thing when working on embedded often more time is spent on
17:33 this it seems than normal operation because often there is not a clear correct answer
17:40 you might like this or dislike it but it's part of working in embedded so now let's look at the api
17:48 for the temp hum module i'll just point out some key structures
17:55 and functions here is the config structure for this module
18:01 and we specify the i2c instance id which is essentially like saying which bus
18:08 the sensor is connected to the i2c address of the sensor
18:14 how often we should be sampling the sensor i believe this defaults to one second
18:20 and this is how much time should we give the sensor to perform the measurement
18:26 and i believe the default is 15 or 16 milliseconds
18:32 here is the form of sensor measurements and we
18:38 the measurements are an integer format but we multiply them by 10 the values by
18:43 10 to get to keep the resolution so this is the degrees c times 10 so if it
18:50 were 20 degrees c this value would be 200 and this is a relative humidity
18:55 times 10 so if the relative humidity was 45 percent this would be 450.
19:02 here are the core module interface functions the standard form and these
19:07 are called from the module startup code and the super loop and in particular the
19:14 uh the run function is the one that's called from the super loop very frequently
19:19 in terms of other apis there's just one and that's to get the last measurement value
19:25 and in addition to the last measurement value this also returns the that the age
19:31 of that measurement so in other words how long ago was it taken you would expect that to be some value less than
19:37 the sample time if the sample time was one second you'd expect this to be
19:43 something less than one second if it's greater than one second it probably means the module is having some
19:49 problem so now we're going to look at the implementation of the temp home module
19:55 and again i'm just going to give a few highlights so first i'll just scroll down and we
20:02 can see the states these were the states in the state machine and then this
20:07 information the data structure that holds the variables for each instance of this
20:12 module and so there are things like the configuration the last measurement value
20:18 and so forth here's the actual state variable
20:24 so now i'm going to go to a particular line
20:33 and this is one of the core interface functions and this is the run function
20:38 which is the one that is called from the super loop so this will be called at a
20:44 very high rate and the bulk of the state machine is in
20:49 this function you'll see that it does a switch on the state and then for
20:55 every state it does whatever it needs to do per the state machine so for in the for example in the case
21:02 when we're in the reserve i2c state it calls i2c reserve
21:08 if it succeeds which means we have gotten control of that bus
21:14 then it does an i2c write and writes the measurement command to the sensor
21:20 and assuming that right succeeds means the initiation was successful then
21:27 we go to the right mesh command and you can go through the rest of this function and it follows the state
21:34 machine diagram i think fairly well there's one more i wanted to take a quick look at and this is the case where
21:42 we're waiting for the measurement value and we call the get op status if it's
21:48 successful that means we have the measurement value so this is doing the
21:53 crc checks on some of those bytes and if those succeed then it's doing the
21:59 conversion of the raw data into temperatures in degrees c and humidity
22:06 and percentage so the last thing i'd like to show is
22:14 the actual crc calculation
22:19 which is 513 at the end of the file
22:25 and this code and i'll show you the function you can see it's not too small or not too big this is not a very
22:32 efficient version of the crc function but it is simple and we're only doing a
22:38 crc over a few bytes so it doesn't have to be that efficient again this came from the web somewhere
22:46 you'll see copies of this all over if you google crc8 c code
22:52 and there are some parameters for this function that come
22:57 from the data sheet for instance the polynomial is an example
23:02 so that's it for the implementation now i want to do a few demos of the temp
23:08 hum module what you see here is the same setup i had before with the i2c module the logic analyzer is on top and the mcu
23:16 console is on the bottom now the temp module is taking samples every second so if we enable the logic
23:23 analyzer we should soon get a trigger and there it is
23:28 and if we look at it in this tabular format we can see a start here
23:34 and there's two bytes of data transferred that would be the command and then 16.7 milliseconds later
23:42 we do another operation and we read six bytes of data
23:47 and that's the measurement result so we've seen this same thing really in the
23:53 i2c demo but let's just look quickly at these
23:59 the signals there is the right and here is the read
24:05 and nothing too special about those now what i'd like to do is reduce the
24:11 amount of time that we wait before we read the measurement as you might remember if you
24:18 read the measurement or try to read the measurement result too soon we have chosen an option where the chip
24:25 will stretch the clock and so we have a temp hum
24:33 test command that allows us to do various things and so one thing it allows us to do is
24:40 change that measurement timer the what you the wait timer so i'm going
24:45 to do a tempum test mesh time instance zero and it was i
24:51 think 16 milliseconds i'm just going to make it 10. so now
24:57 if we get another trigger
25:02 here is the right of the the measurement command
25:09 and then if we look at the timestamps on here we'll see that about 10 milliseconds well 9.8 milliseconds later
25:17 we start to do the read and but then you'll see a gap in time here there's about three milliseconds
25:25 uh gap and so let's look at that that read operation
25:30 so here it is you can here is the address being sent and the next thing that should happen is
25:37 we should start reading the data well what has happened is someone is holding the clock down
25:44 and that someone is the sensor chip because it's doing a [Music]
25:49 it's doing this clock stretching while it finishes the measurement and if we keep going here it's holding it down
25:56 it's holding it down i'm just going to jump straight to it so here it was holding it down finally
26:03 it released the clock so now the master can continue going and
26:08 now it's reading the measurement data so that is a rather
26:13 long clock stretch of three milliseconds but it is part of
26:18 i2c and and it did its purpose here the other thing i'd like to show you
26:26 is the crca calculations and in this test command i also have a test
26:33 where you can provide data and it will do the crc so what i am going to do is do
26:40 test crc eight and if we take the last these two bytes of
26:47 the humidity data zero x eight f
26:53 and this one is 0x98
26:58 and compute the crc8 the answer is 0xbb which hopefully
27:05 is this and it's not what did i do wrong
27:12 ah that's not 9 8 that's 9b let's try it again temp um well
27:18 here this is a lot easier 9b
27:24 okay now the result is e8 which matches this e8 good
27:29 so that is the crc function that will you know helps
27:34 verify that there were no errors and you could you saw it at work here i put in the wrong byte and the crc did not match
27:42 finally i'm going to show you something that i came across that is not so nice i'm first going to stop uh temp hum from
27:49 taking measurements and the way i do this is by reserving the bus and that'll block it so we can do an i2c
27:56 test reserve instance zero and that worked
28:03 so now let's try to read a measurement result without first giving a
28:08 measurement command so i'm going to start the analyzer and i am going to do an i2c
28:17 test read instance 0 address 44
28:22 and we want to read uh six bytes
28:27 well let's see what happened we don't have we don't have many bytes here if we
28:32 looked at what happened is here's the address byte and it looks like
28:38 the sensor is stretching the bus or stretching the clock
28:43 however if i start tracing again that signal is still low it's stretching
28:49 it forever so we're now in a situation where the clock signal is being pulled low by the sensor chip
28:57 and there's no way to get out of this we cannot communicate on this bus i mean if i try to do another read just to show
29:04 you what would happen we get return code minus seven um actually i should then do an i2c
29:12 test status 0. we get so this minus 7 means there was a
29:18 peripheral error and if we look at the if we look in the
29:24 i2c header error 2 is bus busy
29:30 so we're stuck now the only way that i can
29:37 cure this is to reset the the sensor chip and i'm going to do that
29:43 right now on the fly by just grounding the reset pin
29:49 and there i did it and so now the clock is back and now we can i'm going to release the
29:56 bus release 0 and
30:02 did i no type i2c test
30:07 oh at least zero okay and there we go so i released the
30:12 bus and um now things are back to normal we did a we did a successful measurement
30:18 now you could argue that well tough luck you didn't issue
30:23 a one-shot measurement command to that sensor chip so when you tried to read it
30:30 you know it it did what it did and it's your fault um and okay i sort of accept that but
30:37 but it's still not very nice if i were using this sensor chip on a product i would put a lot of thought
30:43 into this because in software systems things happen and especially software systems that run
30:51 24x7 for days and months you know things happen and you don't
30:56 want to get stuck like this so if i were putting this into a product i would
31:02 think about how from software i could recover from this condition
31:07 without having to maybe even reset the mcu resetting the mcu would be one choice if that resets the other hardware
31:14 on the board another possibility is i have a gpi connect gpio connected to the
31:20 reset pin of that sensor and and that way i could i could uh reset that sensor on its own
31:29 but it is uh always good to try these things and try odd things and see how these devices behave
31:36 because you'd rather know early than find out about it late
31:41 now so far we have looked at the messages on the wire but have not actually seen the temperature and
31:47 humidity values so we need to look at those so there are two ways to get those one is i have a test command option to
31:55 print the last measurement so temp hum test
32:02 and it's get last mesh so temp hum test
32:07 uh last mesh and instance zero and so there you see uh 22.4 degrees uh
32:17 49.7 uh percent humidity and um
32:22 and there's the age of the measurement which is 885 milliseconds and remember we're doing a sample each second
32:29 the other thing i can do is i have a log statement that prints out the measurement value
32:36 every time a sample is done and so let me enable the logging and so there you see once a second we're
32:44 printing it and um in this case it's printing the value in raw form so those
32:49 are those numbers are should be divided by 10. you can see that the humidity is changing a little
32:57 bit um the temperature is pretty constant at 22.4 or there it went up to
33:02 22.5 degrees c so there it it is doing what it is uh
33:08 intended to do so here is a short summary of this lesson use of the generic i2c module simplifies
33:17 the implementation of the temp hum device specific module and it also
33:22 provides other advantages such such as simple sharing of the i2c bus
33:28 a state machine was again used to orchestrate a sequence of i2c transactions to perform the measurement
33:35 task this sensor device used crcs to verify
33:41 the integrity of data transferred across the i2c bus
33:47 and the demo showed us that it is good to experiment with i2c devices to see
33:52 how they respond to unexpected i2c read and write operations murphy's law says
33:58 that anything that can go wrong will go wrong so you need to think about the need for
34:04 recovery mechanism if a device in the case of a device gets stuck in some bad state
34:11 here are the prompts for this video lesson i'll pause here for a few seconds in case you want to pause the video and
34:16 look at them as a group on the next set of slides i'll go through the prompts one by one and reveal my take
34:26 if you had two sht31-d sensors with the same address on a
34:32 single bus how would you likely detect it
34:39 well the measurement data will likely be corrupted assuming the data sent by the two sensors is not exactly
34:46 the same and we saw how that worked on in the last lesson and if the data is corrupted you will
34:53 very likely get a crc failure
34:60 per the data sheet what are the three ways to reset the sensor chip
35:10 well there's a soft reset which is actually an i2c command we haven't looked at that command but
35:18 it's something we could implement you can pulse the end reset pin and that's actually what i did in the demo
35:24 when we got that chip where it was holding the clock signal down or you can power cycle the chip
35:35 what is the recommended method for resetting the chip the sensor chip that does not involve removing the power
35:41 supply what do you think is the reason for the choice and again this is from the data sheet
35:51 well the recommended meth method is to pulse the the end reset uh pin and not
35:57 to use a soft reset and pulsing the end reset pin is more reliable than the soft reset
36:04 because it doesn't depend on i2c communications working properly and this again is what we saw during that demo
36:13 per the data sheet does the sensor chip support any combined format messages
36:24 well the answer is yes it does and the thing to look for is an i2c transaction with more than one
36:32 start condition before the stop condition and that means it must be combined format and i believe they're all
36:39 right followed by a read so the two examples i saw were the fetch
36:44 data command which is in table 11 and the read status register command
36:50 that is in table 17. well this is the end of the lesson i
36:56 hope you found it useful and thanks for watching