00:01 in this lesson we cover the i2c theory of operation you can see the topics here
00:06 which i'll go through quickly we start with an introduction which includes advantages and disadvantages of
00:12 i2c compared to other serial buses next we'll cover terminology and some of the
00:19 basic concepts of i2c then we'll look at open how open drain
00:25 signals work and this is a hardware concept but it's not too hard to understand
00:31 we'll look at a circuit that shows how i2c devices are connected to an mcu
00:38 and following that we'll look at the details step by step of how
00:43 the i2c bus operates next we'll look at some other i2c
00:49 features and procedures these are less commonly used but it's good to be aware of them
00:54 finally after a very short summary i'll provide some prompts or questions for
00:60 you to try to answer for each prompt i'll give you a second to pause the video if you'd like and then give you my
01:06 take on the prompt now down here in this box is a reference
01:12 to the i2c specification as specs go i find this one fairly easy to read and i
01:18 encourage you to take a look at it you might notice that nxp writes the spec and of course they make a lot of chips
01:25 including mcus let's start with an introduction to i2c
01:32 so i2c stands for inter-integrated circuit and is pronounced either i2c or
01:38 i squared c it's one of several serial communication methods you'll see in embedded systems
01:45 i2c is commonly used for an mcu to communicate with external sensors
01:51 external memory i o extenders displays and other devices
01:57 other serial communication methods are asynchronous serial which uses a uart spi and can
02:05 these different interfaces tend to have different intended uses and with that different advantages and disadvantages
02:12 for example i2c and spi tend to be local to a board or a closely connected set of
02:18 boards so the bus would normally be no longer than a meter of course there are exceptions in contrast can and some
02:26 types of asynchronous cereal can be used for 100 meters or more
02:31 so in looking at i2c advantages and disadvantages we will mainly be
02:36 comparing it to spi and asynchronous serial and by the way you can google i2c
02:42 versus spi and get lots of information on this subject so let's start with some advantages of
02:48 i2c this first one might be the biggest you can communicate with multiple devices
02:54 with just two signals besides ground with spi you need more signals often
03:00 including one dedicated signal for each device another advantage is there is some
03:07 built-in error detection as we shall see act signals are used to give a positive
03:14 confirmation of correct operation with spi there are some error conditions that can go undetected
03:22 and compared to asynchronous serial i2c does message
03:27 framing in other words you don't have to write code that determines the starting and ending points of a message
03:34 so now for some disadvantages of i2c this first one speed is probably the
03:40 biggest disadvantage the main reason for this slower speed is the use of open drain bus signals this is an electrical
03:47 issue using open drain helps to reduce the number of signals needed by allowing
03:53 them to be shared between devices but it slows things down
03:58 because of open drain you often need pull up resistors with i2c it
04:04 isn't a big deal but it is a minor cost and it takes up a little board space
04:11 and the final disadvantage i list is possible address conflicts it is hard to
04:16 say how often this is a problem but it does happen and i'll wait until we talk more about
04:22 i2c addressing before explaining this so now that we have found out how i2c is
04:29 used and what its advantages and disadvantages are let's start learning about some terminology and concepts
04:36 so first let me just define a term a transaction is the transfer of
04:42 information on the i2c bus between devices it can consist of one or more read and
04:49 write operations as we shall see there are distinct markers at the start and end of a
04:55 transaction now let's talk about addresses
05:00 because multiple i2c devices can be connected to the same bus there must be a way for devices to
05:07 identify each other this is done via an address each device on a bus must have its own
05:14 unique address the way this works is that the first
05:19 byte written to the bus in an i2c transaction contains the address of the
05:25 target device so the selected target device will participate
05:31 and all of the other devices on the bus will stay silent
05:37 now addresses are normally 7 bits in length we will talk about 10-bit
05:42 addresses later the next concept is master and slave
05:49 for a particular transaction there is a master that initiates the transaction and a slave that reacts to it
05:57 so at the start of a transaction the master sends an address to select a particular slave on the bus
06:05 it's most common that an mcu is a master and some external device like a sensor
06:11 is the slave however an mcu can act as a slave for some applications
06:19 now it's most common that there is a single master on the bus a bus with multiple masters is possible
06:27 but we will focus on the single master case in this course one last thing i want to mention is that
06:33 in an i2c transaction the master has no address it doesn't need one
06:40 now let's talk about open drain electrical signals and i need to mention there is something very similar called
06:46 open collector and you can view them as the same and open drain is just an electrical
06:53 technique to share a signal between devices so here we have a signal
06:60 and i just call it an i2c bus signal now with i2c there are actually two open
07:06 drain signals but i show one here just to keep it simple and as you can see there are three
07:13 i2c devices connected to this open drain signal an mcu a sensor and an a to d
07:19 converter and i show that each device is connected to ground which is zero volts
07:26 often ground connections are not shown on schematics and they're just assumed but on this first slide i include it
07:34 and as seen here ground is all is sometimes called uh vss or labeled vss
07:40 uh where s means source or v e where e means emitter now there are technical
07:47 reasons why they use all of these names which you don't really need to worry
07:52 about so the bus signal is at the high level by default due to this
07:59 pull-up resistor in other words this resistor pulls up the signal
08:05 to the to the high level now this high level is in reality a high voltage level
08:11 normally either 3.3 or 5 volts but we can just call it a high level
08:16 and as seen here it is sometimes this high level sometimes labeled vdd for
08:23 drain or vcc for collector so devices any of these three
08:31 just leave the signal alone if they want it to be high because the pull up resistor is pulling
08:36 it high but they pull it down to make it low when any of these devices pulls the
08:43 signal low it overpower overpowers this pull-up resistor
08:49 as soon as the device leaves it alone it'll the pull-up resistor will pull it back high again now i show this concept
08:56 in a little more detail in this yellow box which contains the bus interface for these i2c devices
09:03 in a very simplified way first it shows that the device can
09:08 always read the level of the signal and it shows that the device can control
09:15 the signal through this conceptual switch when the switch is open as it is here it has no influence over the signal
09:23 level but if it closes the switch connects this
09:29 that will connect the signal to ground and make it low so the switch overpowers
09:35 the pull-up resistor so these devices can control the level
09:40 of the signal and can also read the level of the signal and this is how data is transferred one device is controlling
09:48 the the signal and another device is reading it now of course for this to work it has to
09:54 be very organized and the i2c protocol specification does this it provides the
10:00 rules for how data transfer works it specifies in great detail a series of
10:05 steps for some operation like a read and for each step how the different devices control or
10:12 read the i2c signals we'll look at this shortly
10:17 here we show an example of an i2c circuit let's imagine this is a controller for a refrigerator we have an
10:24 mcu and four other i2c devices three temperature sensors and an a to d
10:30 converter you'll notice that there are two i2c buses on this
10:36 board and we'll talk about the reason why in just a minute each bus has two signals and these
10:43 signals are open drain as we just discussed and they have pull-up resistors
10:49 one thing i did on this drawing is show two styles for drawing resistors on a schematic the traditional style is the
10:56 zigzag style which i like but you will also see these rectangular
11:01 style and of course no one would mix styles on a single drawing which is what i did here
11:07 so again we see that the i2c bus has two signals sda and
11:13 scl and sda is used to transmit and receive data
11:19 serial data that's the sda and the other signal is the serial clock and that's
11:26 where the scl comes from we will see later how these signals work
11:32 as i mentioned the i2c master is typically the mcu and
11:37 there is only one and that's what i show here and i to select 2c slaves are typically
11:45 sensors a d converters memory io expanders and so forth and
11:50 this is what i show here also we talked about i2c addresses and that
11:55 each slave on a particular i2c bus must have a unique address
12:01 now this node here says that the temperature sensor can only be configured to have
12:07 addresses hex 44 or address hex 45 and this is exactly the case with the
12:14 temperature sensor i use in this course it is limited to these two addresses and that kind of address limitation is
12:21 common in i2c devices so if we need three temperature sensors
12:26 and if we had just a single i2c bus we'd have a problem we have three devices but
12:32 only two unique addresses now there are different solutions to this problem and they all involve
12:38 hardware design in some way this drawing shows one particular solution and that is you just add a
12:45 second i2c bus so now we have two sensors with address
12:51 45 this one and this one but they're on different buses so it works fine
12:56 this is a simple and fairly cheap solution if you if you have a spare i2c
13:01 bus on your mcu and that's not unusual the mcu we are using in this course has
13:07 three i2c bus interfaces so this would work now let's talk about i2c bus operations
13:15 they occur as a series of steps as i'll describe here i'll first start with this very abstract diagram to focus on the
13:22 steps before we start looking at the details of the sda and scl signals
13:27 so first your software running on the mcu acquires the bus
13:32 both the sda and scl signals must be high which indicate the bus is idle if you have a
13:39 single master this should always be the case however i would not rule out the case that if you start a new transaction
13:46 immediately after a previous one ended or after some bus error you might have
13:52 to wait a short time and retry next the master generates the start
13:58 condition on the bus this tells all slaves to wake up and
14:03 start listening this is the start of the i2c transaction
14:09 next the master sends the slave i2c address followed by a read
14:16 write bit that tells the slave whether the master wants to read data or write data
14:22 so all the slaves compare this address that the master sent with their own address
14:28 if there is a uh if there's an address match then the slave sends an ack
14:35 and all the other slaves uh stay silent but what if the address did not match
14:41 any slave well no one would send a knack and the absence of an ack is considered
14:47 a knack nack knack stands for not acknowledge
14:52 so if the master detects a knack it will stop the transaction there
14:57 because there's no one to talk to and we'll look at this case in one of the demos
15:02 but assuming an act was sent by a slave we are now ready for the data transfer
15:09 so there is the right case and the read case i show them both here but only one
15:15 will occur and the way they work is similar in each case the sender
15:22 which would either be the uh the master or the slave transmits a data byte and the receiver
15:29 sends an ack and this process repeats for each byte and these arrows here are meant to
15:36 indicate this is a loop now the way the data transfer ends
15:42 is different between reads and writes for a write
15:47 normally the master simply stops sending when it has sent all the bytes
15:53 at once it is not common but possible though for the slave to terminate the
15:59 transfer before that by not acting a bite again the absence
16:04 of an ack is viewed as a knack for a read
16:10 it is normal for the slave to send bites until the
16:15 master has what it wants the master knacks the last bite at once
16:20 and the slave knows that data transfer has ended so in both the read and the right cases
16:26 the master generally controls how many bytes are transferred
16:32 and then finally the master generates the stop condition this indicates to all
16:37 devices that the transaction is over and the bus is idle now one thing i should say is that the
16:44 i2c specification for for the most part says nothing about the meaning of what
16:50 these data bytes contain that is all up to the individual i2c devices such as sensors or memory
16:60 so now i'm going to repeat what we saw in the last slide but this time in terms of the sda and scl signals
17:07 for those of you who have not seen signal diagrams like this before i'm going to spend a little time up front
17:13 explaining them so here are the two signals sda and scl
17:18 and these traces are showing the state of those signals high or low as we go
17:24 forward in time from left to right in terms of data
17:29 a low signal indicates a zero bit and a high signal indicates a one bit
17:36 in terms of axe and max a low value indicates a ack and a high value
17:44 indicates a knack now you'll notice areas where the sda signal is both high and
17:51 low at the same time now what that means is we don't know the value of the signal
17:57 and so in this case it's the address being sent we don't know what the address would be so it's going to be
18:04 zeros and ones through here on the other hand in the case here where the ack is being
18:10 sent we know that it's an ack and it's not a knack
18:16 and so that's why it's low here how do we know it's has to be an ack it's because if it was
18:21 a knack the transaction would be ending we wouldn't continue on with data transfer
18:28 so the sda signal has bit values and acknack values and it goes high and low
18:34 to convey this information the question is if you were trying to receive these bits you would say well
18:40 where does a particular bit start and end and this is where the clock signal comes
18:46 in and it's fairly simple for i2c whenever a clock signal goes from low to
18:53 high you should look at the value of the sda
18:58 and that will tell you whether it's a low or a high so a hardware designer would say that we
19:04 sample the data signal on the rising edge of the clock signal
19:10 and after the falling edge of the clock signal for example here
19:15 that is when it is time to change the sda signal to be ready for the next
19:22 bit and that's what it's showing right here the sda signal may change at that point
19:29 so this here indicates a set one to seven indicates
19:35 that there will be seven rising edges of the clock signal for the seven bits of the address and that and
19:42 the values of those bits will be up here and again we sample them when the
19:48 clock rises and then this rising edge here is
19:53 indicates when to look for the reed right bit and this rising edge here indicates when
20:01 to look for the acknack signal one important thing i want to say about
20:06 acnac for the address and read write bits the master was controlling sda
20:13 but the slave sends the act knack so right after the read write bit
20:19 the master lets go of the sda signal and that allows the slave to control it
20:26 and this is where the idea of open drain comes into play however i should mention that even
20:33 though in this case the slave is controlling the sda the
20:38 master always controls the uh clock signal and i should say
20:44 almost always cl controls the clock signal there is an exception i'll talk about in a little bit
20:50 so once you get the idea of the clock signal and how it tells you
20:55 when to sample the data signal you've learned a key concept in digital sequential logic
21:04 so transmitting data bytes works the same way as the address and read write bit
21:10 depending on whether it's a read or a write either the master or the slave will be putting its bits on the sda
21:18 signal and whether it's a read or a write will determine whether the master the slave is the one
21:26 sending the act signal here so this is how the bus works
21:32 once you get the idea it isn't hard and we'll be looking at more of these diagrams on a logic analyzer in a
21:38 following lesson now the final thing i need to mention are the start and stop conditions
21:45 for instance here these are special unique bus signal patterns the uniqueness is based on the
21:52 fact that when data is being transmitted the sda signal does not change while the scl signal the
22:01 clock is high if that does happen it's a start or a stop
22:07 so a start condition is when there is a falling edge on sda
22:13 while the clock is high and a stop condition is when there's a rising edge on sda
22:20 while the clock is high so that's it for the bus operation at
22:26 the sda and scl level so we've seen the basic operation of the
22:33 i2c bus over the next few slides i want to discuss a number of i2c features and
22:39 procedures that i didn't really explain yet some of these are not commonly used but
22:45 it is good to be aware of them unfortunately i'm not covering everything there is even more if you
22:51 want to learn about these other things i suggest you take a look at the i2c
22:57 specification it's not that hard to read and at this point a lot of it should look familiar
23:04 so i've referred to multi-master before and the main thing it adds is bus arbitration
23:12 so when a master wants to use the bus it first has to check if it's busy
23:18 and if it is busy it means there's another master using it and it needs to back off and
23:25 try again later so that handles most of the arbitration
23:31 the tricky case though is when both masters try to use the bus at
23:38 exactly the same time they both see the bus as non-busy and they both start to use it this is known
23:45 as a collision now there is a hardware method for the two masters to detect that a collision
23:51 is occurring and for exactly one of the masters to back off the other master will keep going and the
23:58 operation should work so now bus speeds the bus speed is how
24:04 many bits can be sent per second and it's more or less the same as the clock frequency the bus speed is stated in
24:11 terms of mode so the original i2c spec
24:16 was standard mode it allows you to go up to 100 kilobits per second things always have to go faster so they
24:23 came up with fast mode which is 400 up to 400 kilobits per second and then you know there's even faster modes
24:30 the bulk of i2c buses probably operate at one of these two modes although these
24:36 faster modes were put in there for a reason so clock stretching is a cool little
24:42 feature suppose the master is trying to write data to a slave and say the slave needs a little extra time
24:49 to process the data after each byte for example the slave can pull down the stl signal
24:57 to low to indicate it's uh needs some time and again it's open drain that allows
25:04 this kind of thing to happen so the master will detect this it'll and it will wait until
25:11 that scl signal goes high again and then it can continue operation
25:18 now the master might also want to slow things down for some reason it's a little bit easier for it since it
25:24 controls the the clock it can just stop the clock and as long as it needs to
25:30 and and then start the clock again when it's when it's ready and the um
25:35 the slaves probably won't even notice this so your software really doesn't have to do
25:43 much there is sometimes an option to allow or disallow clock stretching but
25:48 for the most part this is just a hardware feature continuing on we have what is known as
25:56 combined format this is a way to do two or more operations in a single bus
26:02 transaction most commonly it is a write and then a read
26:07 so typically the right data specifies what is to be read for example a memory
26:13 address or a register number and then that value is read so here we can see how this works
26:21 we we do the first operation is normal through here
26:26 and then where we would normally generate a stop condition
26:32 we generate another start condition this is called a repeated start
26:39 then we do the next operation just as we would before and in that case
26:45 this is the like if this is the last operation we generate a stop condition
26:52 now the significance of this feature is it's slightly more efficient use of
26:57 the bus by having just a single transaction but perhaps the most significant thing
27:04 is it acts as a single atomic operation no intervening bus transactions can
27:11 occur between these two operations and we'll look at that in one of the
27:17 prompts at the end of the lesson so this is the last slide in the
27:25 set of features and procedures so we have here 10-bit addresses which
27:31 is obviously an extension of the normal 7-bit addresses
27:36 10-bit addresses are not commonly used but they are possible as you might expect an extra byte has
27:43 been added to the message formats for these extended
27:49 addresses it has been designed so that a single bus can have both 7 and 10 bit addresses
27:57 and you might wonder how can you do this well what has been done
28:03 is that seven bit addresses with values that look like this
28:09 four ones and a zero followed by uh two other bits are reserved
28:15 they can't be used for any 7-bit address device and so the way this works is when the
28:23 master wants to talk to a 10-bit address it sends first
28:29 a 7-bit address of this form this here is the reserve pattern so no 7-bit
28:36 device will match this and in this byte these last two bits
28:43 represent the first two bits of the 10-bit address so
28:49 if any 10-bit devices match this they will send an ack
28:55 might be more than one because we're only talking about the first two bits and open drain allows
29:02 multiple devices to send an ack then the master sends the second
29:08 byte and eight bits here plus two bits here that's your 10 bits now there should be
29:14 no more than one device who recognizes that address as its own and if so it will send the ack
29:22 this is the important knack if this act comes through now the data
29:28 transfer starts and this all works the same as before so that's how 10-bit addresses work
29:35 the final feature is called general call address and what this is is that
29:42 a an address value of zero is also a reserved value and what it is used to do
29:48 is to broadcast messages to all slave devices so all slave devices
29:55 if they support this we'll recognize that address zero this is a little bit different than
30:02 other myths other kinds of messages because the standard talks about the data portion of the
30:08 message and it had the standard has defined some standard procedures
30:14 for devices to support one of them is a soft reset of the
30:19 device so the idea is that with a single message the master can tell all the
30:25 slaves to do a soft reset of course the master doesn't know whether they've received it and whether
30:31 they've done it but it is possible
30:37 to summarize this lesson i2c is one of several types of serial
30:42 communication used with mcus some others being spi and asynchronous serial
30:49 i2c is normally used for short distances typically on a single board or a set of
30:55 closely connected boards a major advantage of i2c is needing only two signals meaning two
31:03 mcu pins to communicate with multiple devices a major disadvantage of i2c is lower
31:10 speeds compared to say spi due to the use of open drain signals
31:19 now i2c bus activity occurs within a transaction between a master and a slave
31:26 typically the master is the mcu and slaves are devices such as sensors
31:32 displays analog to digital converters each slave on a bus has a unique i2c
31:41 address the master sends the slave address at
31:46 the start of a transaction the corresponding slave sends an ack and then the data transfer occurs
31:54 here are the prompts for this video lesson i'll pause here for a few seconds in case you want to pause the video and
31:59 look at them on the next set of slides i'll go through these prompts one by one with my take
32:09 with the sht 31-d temperature sensor chip that we use in this course you can
32:15 choose the i2c address 44 or 45 on the fly by connecting a control signal to
32:22 the adder input on the chip how could this be used to support more than two such sensors on a single i2c bus
32:33 well my solution isn't very clever but i think it will work it requires one gpio
32:38 output pin for each sensor chip connected to the adder input pin on the
32:44 chip so say you have four sensors a b c and d if you want to access sensor b
32:51 set its adder input via the gpio so it uses address 45.
32:58 use the gpios for the other sensors so they use address 44.
33:04 then you do the i2c transactions using address 45 you will talk to sensor b and
33:10 the other sensors will ignore you now this appears to break the rule of every device has to
33:17 have a unique address but really i guess i should say every every device that you're actually going
33:24 to use has to have a unique address these sensors when they are set for
33:29 address 44 are not ever going to be used with that address
33:35 why might the master on an mcu stretch the clock
33:43 well i can think of two and to be honest i got these based on reading the
33:49 mcu reference manual and there might be other scenarios but these are the two i'm aware of
33:55 so in the case of a write if the mcu software is not providing
34:00 data to the i2c peripheral fast enough in a transaction then the i2c peripheral
34:06 is forced to stretch the clock until it gets more data what else is it going to do
34:13 in the case of the read if the mcu software is not fetching data from the
34:18 i2c peripheral fast enough the i2c peripheral will have no room to store
34:24 more input data and it's forced to stretch the clock to stop the slave
34:30 sending data now in these cases for instance in the driver we develop the i2c peripheral
34:38 would be interrupting or sending interrupts to the mcu trying to tell it you know
34:44 there's data for you to read or i need more data but of course you can't force the mcu
34:50 software to do that so that's when this would occur
34:55 suppose you have two sensors on an i2c bus and you cannot achieve a fast enough sample rate due to the bus
35:03 describe possible solutions
35:09 well this is a pretty open question my first response is to improve your code
35:16 there might be bugs in it or something it might just be doing something stupid that is limiting the throughput it's
35:23 hard to say the next two are a little bit more clear one is to go to a higher bus speed so if
35:30 all the devices on the bus support say 400 kilobits but you're only running at 100 kilobits well you
35:37 can get quite a speed increase there another possibility is to put the
35:43 devices on separate i2c buses so you can communicate with them in parallel
35:49 that obviously will should you know more or less double the throughput
35:57 assume you have an i2c memory device and to read a memory location you first do an i2c write to indicate which location
36:05 you want and then you do an i2c read to get the value of that location
36:12 in the case of multi-master what is the danger if you do not use the combined format to do the right plus read
36:24 well the the scenario that would cause a problem is master one writes that address value
36:32 and now it wants to read the value but master two sneaks in and gets the bus and writes a
36:39 different address value then master one finally does its read
36:44 and it gets the value for the wrong address so this interleaved use of the bus is
36:51 what is the danger now with combined formats the write and
36:56 then and the read operation is done in a single atomic bus operation
37:02 and so master two could not sneak in between the write and the read of master
37:08 one
37:13 describe limitations of using an i2c software reset command to fix a stuck
37:19 device and i think i briefly mentioned the ability for a master
37:25 to send a reset command to a slave telling it you know restart yourself and
37:32 this might be done in response to some kind of problems on the bus
37:43 well i thought there were two i can really only come up with one now and that is the stuck device might be
37:49 holding down the sda or scl bus signals in which case you can't do anything on the bus or it might have a problem in
37:56 its i2c interface in which case communication to it is impossible so the
38:02 main problem is the device has to be somewhat working to even send a software
38:07 reset to it suppose you had two slaves on a bus with
38:12 identical addresses and the master tried to do a read of one byte using that address the one slave tried to respond
38:20 with a value of hex fa and the other slave tried to respond with a value of hex 0f would the
38:27 transaction work and if so what value would the master receive
38:35 well the answer to this depends on the fact that with open drain a low signal takes precedence over a high signal so
38:42 if one device is sending low and the other device is sending high and keep in
38:47 mind sending high means you just leave the signal alone then the
38:54 overall result is a low signal so the transaction would work
38:60 both slaves would act the address which is a low and the master would read that act with no problem
39:07 with regard to data one slave sends fa
39:12 which in binary is this and the other slave sends hex 0f which in binary is
39:19 this and if you take these two binary strings and consider them being
39:26 sent bit by bit and keeping in mind that a if there's a
39:32 zero and a one the net result will be a zero then when you combine them you will get
39:39 this value which in hex is 0a
39:44 and that's what the master would receive and keep in mind that the master would not
39:50 be aware that two slave devices responded and the slaves would not really be aware
39:57 that they were responding in parallel with each other
40:02 well this was a long lesson i hope it was useful for you and thanks for watching